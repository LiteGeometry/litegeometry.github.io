{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to LiteGeometry","text":""},{"location":"#about-the-project","title":"About The Project","text":"<p>LiteGeometry is a lightweight C++ library \u2014 built on top of Eigen \u2014 that delivers high-performance 2D and 3D computational geometry and path-planning utilities.</p> <p> </p> <p>Whether you're building quick prototypes or deploying models in production, LiteGeometry ensures a fast, reliable, and scalable experience.</p>"},{"location":"#why-use-litegeometry","title":"Why Use LiteGeometry?","text":"<ul> <li> <p>Simplicity: Clean and intuitive API design that makes the library easy to use and integrate.</p> </li> <li> <p>Performance: Efficient implementations for common geometry and planning tasks.</p> </li> <li> <p>Utility: A wide selection of common geometric algorithms and advanced path planning techniques.</p> </li> </ul>"},{"location":"#key-modules","title":"Key Modules","text":"<ol> <li> <p>Core Geometry Utilities</p> <p>Provides fundamental 2D/3D geometry operations, such as:</p> <ul> <li>Containment queries for points relative to lines, polygons, and polyhedra.</li> <li>Exact intersection tests between segments and other shapes (lines, polygons, and polyhedra), including precise computation of intersection points.</li> </ul> </li> <li> <p>Advanced Modeling Algorithms</p> <p>Supports advanced modeling tasks, including:</p> <ul> <li>Oriented Bounding Box (OBB) construction in both 2D and 3D.</li> <li>Rasterization routines for lines, polygons, and polyhedron surfaces.</li> <li>A pinhole-camera model for projecting 3D points onto a 2D image plane.</li> </ul> </li> <li> <p>Path Planning</p> <p>Specialized algorithms for efficient pathfinding:</p> <ul> <li>Two optimized 3D Jump-Point Search (JPS) implementations for large-scale environments.</li> </ul> </li> </ol>"},{"location":"#development-environment","title":"Development Environment","text":"<p>This library is actively developed and tested with:</p> <ul> <li>Compiler: MSVC 2022 (C++17 mode)</li> <li>Eigen: 3.4.90</li> <li>CGAL: 5.6</li> <li>Boost: 1.87.0</li> <li>Abseil: 20240116</li> </ul>"},{"location":"#examples-and-tutorials","title":"Examples and tutorials","text":"<p>Explore LiteGeometry extensive list of examples and tutorials to get you started with LiteGeometry. You can find them here.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>LiteGeometry defines explicit types for segments, rays, and infinite lines in 2D and 3D:</p> <pre><code>// -------- 2-D --------\nstruct Segment2D { Eigen::RowVector2d P1, P2; };\nstruct Ray2D     { Eigen::RowVector2d P1, P2; };  // Direction: P1 \u279c P2\nstruct Line2D    { Eigen::RowVector2d P1, P2; };\n\n// -------- 3-D --------\nstruct Segment3D { Eigen::RowVector3d P1, P2; };\nstruct Ray3D     { Eigen::RowVector3d P1, P2; };  // Direction: P1 \u279c P2\nstruct Line3D    { Eigen::RowVector3d P1, P2; };\n</code></pre> <p>\ud83d\udca1Tip: All line-based utilities accept these primitives directly.</p> <p>Import Header: <pre><code>#include \"LiteGeometry.h\"\n</code></pre></p> <p>Check if two 2D segments intersect and compute the intersection point: <pre><code>int main(){\n    Eigen::RowVector2d A(0.5, 1.2);\n    Eigen::RowVector2d B(3.7, 2.8);\n    Segment2D AB{ A , B };\n\n    Eigen::RowVector2d C(1.0, 3.0);\n    Eigen::RowVector2d D(3.0, 0.5);\n    Segment2D CD{ C , D };\n\n    Eigen::RowVector2d intersection;\n    bool isIntersection = isLinesIntersection2D(AB, CD, intersection);\n\n    if (isIntersection) {\n        std::cout &lt;&lt; \"Intersection Point:\\n\"\n            &lt;&lt; intersection.format(Eigen::FullPrecision) &lt;&lt; std::endl;\n    }\n\n}\n</code></pre></p> <p>Output: <pre><code>Intersection Point:\n1.8857142857142859 1.8928571428571428\n</code></pre></p> <p></p> \u00d7 <p>Check if two 2D rays intersect and compute the intersection point: <pre><code>int main(){\n    Eigen::RowVector2d A(0.0, 0.0);\n    Eigen::RowVector2d B(3.0, 0.9);\n    Ray2D AB{ A , B };\n\n    Eigen::RowVector2d C(0.5, 3.2);\n    Eigen::RowVector2d D(2.3, 2.5);\n    Ray2D CD{ C , D };\n\n    Eigen::RowVector2d intersection;\n    bool isIntersection = isLinesIntersection2D(AB, CD, intersection);\n    if (isIntersection) {\n        std::cout &lt;&lt; \"Intersection Point:\\n\"\n            &lt;&lt; intersection.format(Eigen::FullPrecision) &lt;&lt; std::endl;\n    }\n\n}\n</code></pre></p> <p>Output: <pre><code>Intersection Point:\n4.9274193548387082 1.4782258064516127\n</code></pre></p> \u00d7"},{"location":"#license","title":"License","text":"<p>LiteGeometry software: BSD-3-Clause License</p>"},{"location":"examples/","title":"Examples and Tutorials","text":"<p>Explore practical implementations of geometric algorithms through detailed, step-by-step examples.</p>"},{"location":"examples/#basic-geometry","title":"Basic Geometry","text":"<p>Fundamental operations such as constructing closed polygons, computing plane normals, and verifying coplanarity.</p> <ul> <li> <p>Generate closed polygons from unordered point sets</p> </li> <li> <p>Compute plane normals from 3D coplanar points </p> </li> <li> <p>Verify coplanarity of 3D point sets </p> </li> </ul>"},{"location":"examples/#point-queries","title":"Point Queries","text":"<p>Techniques for determining spatial relationships between points and other primitives (lines, polygons, polyhedra).</p> <ul> <li> <p>Determine point-line coincidence (2D/3D)</p> </li> <li> <p>Test point-in-polygon containment (2D/3D)</p> </li> <li> <p>Check point-in-polyhedron containment</p> </li> </ul>"},{"location":"examples/#line-surface-queries","title":"Line &amp; Surface Queries","text":"<p>Intersection detection and distance computations between lines, polygons, and polyhedra.</p> <ul> <li> <p>Compute minimum distance between two 3D line primitives</p> </li> <li> <p>Detect line-line intersections (2D/3D) </p> </li> <li> <p>Determine line-polygon intersections (2D/3D)</p> </li> <li> <p>Identify line-polyhedron intersections.</p> </li> </ul>"},{"location":"examples/#oriented-bounding-containers","title":"Oriented Bounding Containers","text":"<p>Compute oriented bounding boxes and rectangles, useful for collision detection and spatial queries.</p> <ul> <li>Generate oriented bounding boxes (PCA-aligned and minimum-volume)</li> </ul>"},{"location":"examples/#point-filtering","title":"Point Filtering","text":"<p>Filter points based on containment within geometric boundaries.</p> <ul> <li> <p>Filter 2D points by polygon containment</p> </li> <li> <p>Filter 3D points by polyhedron containment</p> </li> </ul>"},{"location":"examples/#pinhole-camera","title":"Pinhole Camera","text":"<p>Project 3D world coordinates to 2D image planes.</p> <ul> <li>Project 3D points to 2D camera coordinates.</li> </ul>"},{"location":"examples/#rasterisation-toolkit","title":"Rasterisation Toolkit","text":"<p>Convert continuous geometric shapes into discrete grid representations.</p> <ul> <li> <p>Rasterization data structures</p> </li> <li> <p>Rasterize lines via Bresenham's algorithm (2D/3D)</p> </li> <li> <p>Rasterize polygon (2D/3D)</p> </li> <li> <p>Rasterize polyhedron surfaces</p> </li> </ul>"},{"location":"examples/#path-planning","title":"Path Planning","text":"<p>Implement and optimize 3D Jump Point Search (JPS) algorithms for large-scale environments.</p> <ul> <li> <p>JPS environment models</p> </li> <li> <p>High-precision JPS with CGAL-AABB</p> </li> <li> <p>Voxel-accelerated JPS</p> </li> </ul>"},{"location":"tutorial/test_RasterizationTool/RasterizationCustomTypes/","title":"Rasterization Custom Types","text":"<p>This document explains the predefined custom types used in the <code>RasterizationTool</code>. The <code>RowVector2iSet</code> and <code>RowVector3iSet</code> types are designed to efficiently manage sets of 2D and 3D integer points, respectively. Both utilize <code>absl::flat_hash_set</code> as their underlying container, with custom hash and equality functors to ensure efficient storage and retrieval of Eigen vector types.</p>"},{"location":"tutorial/test_RasterizationTool/RasterizationCustomTypes/#point-set-type-aliases","title":"Point-Set Type Aliases","text":""},{"location":"tutorial/test_RasterizationTool/RasterizationCustomTypes/#rowvector2iset","title":"<code>RowVector2iSet</code>","text":"<pre><code>using RowVector2iSet = absl::flat_hash_set&lt;Eigen::RowVector2i, EigenRowVectoriHash, EigenRowVectoriEqual&gt;;\n</code></pre> <p>This alias represents a set of unique 2D integer points, with each point stored as an <code>Eigen::RowVector2i</code>.</p> <p>It provides fast lookup and insertion using <code>absl::flat_hash_set</code>, and is well-suited for 2D grid-based rasterization and planar geometry processing tasks.</p>"},{"location":"tutorial/test_RasterizationTool/RasterizationCustomTypes/#rowvector3iset","title":"<code>RowVector3iSet</code>","text":"<pre><code>using RowVector3iSet = absl::flat_hash_set&lt;Eigen::RowVector3i, EigenRowVectoriHash, EigenRowVectoriEqual&gt;;\n</code></pre> <p>This alias defines a set of unique 3D integer points stored as <code>Eigen::RowVector3i</code>.</p> <p>It offers the same performance benefits as the 2D variant, and is particularly suitable for large-scale point cloud processing and 3D spatial indexing, due to the combination of <code>absl::flat_hash_set</code> and customized hashing and equality comparisons.</p>"},{"location":"tutorial/test_RasterizationTool/RasterizationCustomTypes/#hash-and-equality-functors","title":"Hash and Equality Functors","text":""},{"location":"tutorial/test_RasterizationTool/RasterizationCustomTypes/#eigenrowvectorihash","title":"<code>EigenRowVectoriHash</code>","text":"<p>The <code>EigenRowVectoriHash</code> struct provides the hash functor required by <code>absl::flat_hash_set</code>. </p> <p>It overloads <code>operator()</code> to support both 2D and 3D vectors, and uses the <code>xxhash</code> algorithm for high-performance hashing.</p> <pre><code>static constexpr uint64_t kSeed = 0x9E3779B97F4A7C15ULL;\nstruct EigenRowVectoriHash {\n    size_t operator()(const Eigen::RowVector2i&amp; v) const noexcept {\n        return static_cast&lt;size_t&gt;(xxh::xxhash&lt;64&gt;(v.data(), sizeof(int) * 2, kSeed));\n    }\n\n    size_t operator()(const Eigen::RowVector3i&amp; v) const {\n        return static_cast&lt;size_t&gt;(xxh::xxhash&lt;64&gt;(v.data(), sizeof(int) * 3, kSeed));\n    }\n};\n</code></pre>"},{"location":"tutorial/test_RasterizationTool/RasterizationCustomTypes/#eigenrowvectoriequal","title":"<code>EigenRowVectoriEqual</code>","text":"<p>The <code>EigenRowVectoriEqual</code> struct defines the equality functor used for comparing <code>Eigen::RowVector2i</code> and <code>Eigen::RowVector3i</code> instances.</p> <p>It enables proper duplicate detection in the hash set by comparing the vectors element-wise.</p> <pre><code>struct EigenRowVectoriEqual {\n    bool operator()(const Eigen::RowVector2i&amp; v1, const Eigen::RowVector2i&amp; v2) const noexcept {\n        return v1 == v2;\n    }\n\n    bool operator()(const Eigen::RowVector3i&amp; v1, const Eigen::RowVector3i&amp; v2) const noexcept {\n        return v1 == v2;\n    }\n};\n</code></pre>"},{"location":"tutorial/test_RasterizationTool/rasterizeBresenhamLine/","title":"rasterizeBresenhamLine (2D &amp; 3D)","text":"<p>These functions implement Bresenham\u2019s algorithm to generate discrete grid points that approximate a line segment in 2D or 3D space. Each function returns a unique set of integer coordinates stored in a <code>RowVector2iSet</code> or <code>RowVector3iSet</code>.</p>"},{"location":"tutorial/test_RasterizationTool/rasterizeBresenhamLine/#function-signatures","title":"Function Signatures","text":""},{"location":"tutorial/test_RasterizationTool/rasterizeBresenhamLine/#2d-version","title":"2D Version","text":"<p><pre><code>RowVector2iSet rasterizeBresenhamLine2D(\n    const Eigen::RowVector2d&amp; p1,\n    const Eigen::RowVector2d&amp; p2\n);\n\nRowVector2iSet rasterizeBresenhamLine2D(\n    const Eigen::RowVector2d&amp; p1,\n    const Eigen::RowVector2d&amp; p2,\n    std::vector&lt;Eigen::RowVector2i&gt;&amp; rawLinePoints\n);\n</code></pre> - Parameters:      - <code>p1</code>, <code>p2</code> (<code>Eigen::RowVector2d</code>): Endpoints of the line segment in 2D space.     - <code>rawLinePoints</code> (optional, <code>std::vector&lt;Eigen::RowVector2i&gt;</code>): Sequence of discrete grid points along the line before corner expansion.</p> <ul> <li>Returns: A <code>RowVector2iSet</code> containing the line points along with their four neighboring corner offsets.</li> </ul>"},{"location":"tutorial/test_RasterizationTool/rasterizeBresenhamLine/#3d-version","title":"3D Version","text":"<p><pre><code>RowVector3iSet rasterizeBresenhamLine3D(\n    const Eigen::RowVector3d&amp; p1,\n    const Eigen::RowVector3d&amp; p2\n);\n\nRowVector3iSet rasterizeBresenhamLine3D(\n    const Eigen::RowVector3d&amp; p1,\n    const Eigen::RowVector3d&amp; p2,\n    std::vector&lt;Eigen::RowVector3i&gt;&amp; rawLinePoints\n);\n</code></pre> - Parameters:      - <code>p1</code>, <code>p2</code> (<code>Eigen::RowVector3d</code>): Endpoints of the line segment in 3D space.     - <code>rawLinePoints</code> (optional, <code>std::vector&lt;Eigen::RowVector3i&gt;</code>): Sequence of discrete voxels along the line before corner expansion.</p> <ul> <li>Returns: A <code>RowVector3iSet</code> containing the line voxels along with their eight neighboring offsets.</li> </ul>"},{"location":"tutorial/test_RasterizationTool/rasterizeBresenhamLine/#example-usage","title":"Example Usage","text":"<pre><code>#include \"RasterizeTool.h\"\n\nint main() {\n\n    Eigen::RowVector3d A(748674.4539194419, 2564739.5306861168, 49);\n    Eigen::RowVector3d B(748694.42507040221, 2564734.3476669602, 81);\n    RowVector3iSet linePointsSet = rasterizeBresenhamLine3D(A, B);\n\n    return 0;\n}\n</code></pre> <p>Below is a visualization of the rasterized 3D line segment between points A and B:</p> <p></p> \u00d7"},{"location":"tutorial/test_RasterizationTool/rasterizePolygon/","title":"rasterizePolygon (2D &amp; 3D)","text":"<p>These functions generate discrete grid points that approximate the boundary and interior of a polygon in 2D or 3D space. Each function returns a unique set of integer coordinates stored in a <code>RowVector2iSet</code> or <code>RowVector3iSet</code>. Neighboring offset points are also included.</p>"},{"location":"tutorial/test_RasterizationTool/rasterizePolygon/#function-signatures","title":"Function Signatures","text":""},{"location":"tutorial/test_RasterizationTool/rasterizePolygon/#2d-version","title":"2D Version","text":"<pre><code>RowVector2iSet rasterizePolygon2D(\n    const Eigen::MatrixX2d&amp; polygonVertices,\n    bool needClosePolygon = true\n);\n</code></pre> <ul> <li> <p>Parameters: </p> <ul> <li><code>polygonVertices</code> (<code>Eigen::MatrixX2d</code>): Vertices of the 2D polygon.  </li> <li><code>needClosePolygon</code> (optional, <code>bool</code>, default = <code>true</code>): <ul> <li>If <code>true</code>, the function automatically sorts the vertices counter-clockwise and ensures the polygon is closed.</li> <li>If <code>false</code>, the input vertices matrix must already be sorted and closed.</li> </ul> </li> </ul> </li> <li> <p>Returns: A <code>RowVector2iSet</code> containing all boundary and interior grid points, plus their four corner offsets.</p> </li> </ul>"},{"location":"tutorial/test_RasterizationTool/rasterizePolygon/#3d-version","title":"3D Version","text":"<pre><code>RowVector3iSet rasterizePolygon3D(\n    const Eigen::MatrixX3d&amp; polygonVertices,\n    bool needClosePolygon = true\n);\n</code></pre> <ul> <li> <p>Parameters: </p> <ul> <li><code>polygonVertices</code> (<code>Eigen::MatrixX3d</code>): Vertices of the 3D polygon.  </li> <li><code>needClosePolygon</code> (optional, <code>bool</code>, default = <code>true</code>): <ul> <li>If <code>true</code>, the function automatically sorts the vertices counter-clockwise and ensures the polygon is closed.</li> <li>If <code>false</code>, the input vertices matrix must already be sorted and closed.</li> </ul> </li> </ul> </li> <li> <p>Returns: A <code>RowVector3iSet</code> containing all boundary and interior voxels, plus their eight surrounding offsets.</p> </li> </ul>"},{"location":"tutorial/test_RasterizationTool/rasterizePolygon/#example-usage","title":"Example Usage","text":"<p><pre><code>#include \"RasterizeTool.h\"\n\nint main() {\n\n    Eigen::Matrix&lt;double, 4, 3&gt; polygonVertices;\n    polygonVertices &lt;&lt; 748694.42507040221, 2564734.3476669602, 49,\n           748674.41542796092, 2564734.5007915981, 49,\n           748674.4539194419, 2564739.5306861168, 81,\n           748694.4635618832, 2564739.3775614789, 81;\n\n    RowVector3iSet PointsSet = rasterizePolygon3D(polygonVertices);\n\n    return 0;\n}\n</code></pre> The figure below shows the result of rasterizing a 3D polygon:</p> <p></p> \u00d7"},{"location":"tutorial/test_RasterizationTool/rasterizePolyhedron/","title":"rasterizePolyhedron","text":"<p>This function generates discrete 3D grid points that approximate the surface of a polyhedron.</p> <p>It returns a unique set of integer coordinates stored in a <code>RowVector3iSet</code>, including corner-based cell expansions around each voxel on the polyhedron\u2019s surface.</p>"},{"location":"tutorial/test_RasterizationTool/rasterizePolyhedron/#function-signatures","title":"Function Signatures","text":"<p><pre><code>RowVector3iSet rasterizePolyhedron(\n    const Eigen::MatrixX3d&amp; polyhedronVertices\n);\n</code></pre> - Parameters:      - <code>polyhedronVertices</code> (<code>Eigen::MatrixX3d</code>): A matrix containing the 3D coordinates of the polyhedron's vertices.</p> <ul> <li>Returns: A <code>RowVector3iSet</code> that includes all surface voxels and their eight surrounding corner offsets.</li> </ul>"},{"location":"tutorial/test_RasterizationTool/rasterizePolyhedron/#example-usage","title":"Example Usage","text":"<pre><code>#include \"RasterizeTool.h\"\n\nint main() {\n    Eigen::Matrix&lt;double, 8, 3&gt; polyhedronVertices; \n    polyhedronVertices &lt;&lt; 748674.4539194419, 2564739.5306861168, 49,\n           748694.4635618832, 2564739.3775614789, 49,\n           748694.42507040221, 2564734.3476669602, 49,\n           748674.41542796092, 2564734.5007915981, 49,\n           748674.4539194419, 2564739.5306861168, 81,\n           748694.4635618832, 2564739.3775614789, 81,\n           748694.42507040221, 2564734.3476669602, 81,\n           748674.41542796092, 2564734.5007915981, 81;\n\n    RowVector3iSet polyhedronPointsSet = rasterizePolyhedron(polyhedronVertices);\n\n    return 0;\n}\n</code></pre> <p>Below is a visualization of the rasterized polyhedron surface: </p> \u00d7"},{"location":"tutorial/test_WorldToCameraImageCoords/WorldToCameraImageCoords/","title":"WorldToCameraImageCoords","text":"<p>This document introduces two overloaded functions that project 3D world points into 2D camera image coordinates using a pinhole camera model. </p>"},{"location":"tutorial/test_WorldToCameraImageCoords/WorldToCameraImageCoords/#function-signatures","title":"Function Signatures","text":"<p>1. Explicit Look\u2011At Projection <pre><code>Eigen::MatrixX2d WorldToCameraImageCoords(\n    const Eigen::MatrixX3d&amp; targetVertices,\n    const Eigen::RowVector3d&amp; cameraDirPoint,\n    const Eigen::RowVector3d&amp; cameraPosition,\n    double FL\n);\n</code></pre></p> <p>2. Centroid\u2011Based Projection <pre><code>Eigen::MatrixX2d WorldToCameraImageCoords(\n    const Eigen::MatrixX3d&amp; targetVertices,\n    const Eigen::RowVector3d&amp; cameraPosition,\n    double FL\n);\n</code></pre></p>"},{"location":"tutorial/test_WorldToCameraImageCoords/WorldToCameraImageCoords/#parameters","title":"Parameters","text":"<ul> <li>targetVertices: <code>Eigen::MatrixX3d</code>, where each row is a 3D point to project.</li> <li>cameraDirPoint: <code>Eigen::RowVector3d</code>, specifying the point the camera looks at (only for overload\u00a01).</li> <li>cameraPosition: <code>Eigen::RowVector3d</code>, representing the camera\u2019s position in world coordinates.</li> <li>FL: <code>double</code> focal length of the pinhole camera.</li> </ul>"},{"location":"tutorial/test_WorldToCameraImageCoords/WorldToCameraImageCoords/#return-value","title":"Return Value","text":"<ul> <li><code>Eigen::MatrixX2d</code>: A matrix of size <code>(N\u00d72)</code>, where each row is the projected 2D image coordinate <code>(u, v)</code> corresponding to an input vertex.</li> </ul>"},{"location":"tutorial/test_WorldToCameraImageCoords/WorldToCameraImageCoords/#example-usage","title":"Example Usage","text":""},{"location":"tutorial/test_WorldToCameraImageCoords/WorldToCameraImageCoords/#1-prepare-input-data","title":"1. Prepare Input Data","text":"<p>Define a cuboid using eight corner points in world coordinates. Also specify the camera\u2019s position, look\u2011at point, and focal length: <pre><code>Eigen::Matrix&lt;double,8,3&gt; testTarget;\ntestTarget &lt;&lt; 748793.66839939367, 2565000.6052587116, 48.909999999999997,\n    748791.82177844818, 2565003.9931349289, 48.909999999999997,\n    748795.20965466544, 2565005.8397558741, 48.909999999999997,\n    748797.05627561093, 2565002.4518796569, 48.909999999999997,\n    748793.66839939367, 2565000.6052587116, 50.909999999999997,\n    748791.82177844818, 2565003.9931349289, 50.909999999999997,\n    748795.20965466544, 2565005.8397558741, 50.909999999999997,\n    748797.05627561093, 2565002.4518796569, 50.909999999999997;\n\nEigen::RowVector3d cameraPosition(748780.10705481586, 2565024.6238759784, 57.51);\nEigen::RowVector3d cameraDirPoint(748794.43902702956, 2565003.2225072929, 49.909999999999997);\ndouble FL = 32.0;\n</code></pre></p> <p></p> \u00d7"},{"location":"tutorial/test_WorldToCameraImageCoords/WorldToCameraImageCoords/#2-perform-3d-to-2d-projection","title":"2. Perform 3D-to-2D Projection","text":"<pre><code>Eigen::Matrix&lt;double, 8, 2&gt; imagePoints = WorldToCameraImageCoords(testTarget, cameraDirPoint, cameraPosition, FL);\n</code></pre>"},{"location":"tutorial/test_WorldToCameraImageCoords/WorldToCameraImageCoords/#3-result","title":"3. Result","text":"<p>The projected 2D image coordinates are visualized below:</p> \u00d7 <p>The red rectangle in the image represents the assumed CMOS sensor area of the camera, with a physical size of 6.4\u202fmm \u00d7 4.8\u202fmm.</p>"},{"location":"tutorial/test_WorldToCameraImageCoords/WorldToCameraImageCoords/#complete-implementation","title":"Complete Implementation","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n\n    Eigen::Matrix&lt;double,8,3&gt; testTarget;\n    testTarget &lt;&lt; 748793.66839939367, 2565000.6052587116, 48.909999999999997,\n        748791.82177844818, 2565003.9931349289, 48.909999999999997,\n        748795.20965466544, 2565005.8397558741, 48.909999999999997,\n        748797.05627561093, 2565002.4518796569, 48.909999999999997,\n        748793.66839939367, 2565000.6052587116, 50.909999999999997,\n        748791.82177844818, 2565003.9931349289, 50.909999999999997,\n        748795.20965466544, 2565005.8397558741, 50.909999999999997,\n        748797.05627561093, 2565002.4518796569, 50.909999999999997;\n\n    Eigen::RowVector3d cameraPosition(748780.10705481586, 2565024.6238759784, 57.51);\n    Eigen::RowVector3d cameraDirPoint(748794.43902702956, 2565003.2225072929, 49.909999999999997);\n    double FL = 32.0;\n    std::cout &lt;&lt; \"Camera Position: \" &lt;&lt; cameraPosition.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Camera Look-at Point: \" &lt;&lt; cameraDirPoint.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Focal Length: \" &lt;&lt; FL &lt;&lt; \"\\n\";\n\n    Eigen::Matrix&lt;double, 8, 2&gt; imagePoints = WorldToCameraImageCoords(testTarget, cameraDirPoint, cameraPosition, FL);\n    std::cout &lt;&lt; \"\\nProjected Image Coordinates:\\n\";\n    std::cout &lt;&lt; imagePoints.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/test_computeBox/computeBox/","title":"Oriented Bounding Box (OBB) Computation","text":"<p>This document outlines a collection of functions for computing oriented bounding rectangles and boxes. Two families of algorithms are provided: those that align the bounding shape with the data\u2019s principal components (PCA-aligned) and those that produce the exact minimum-area (2D) or minimum-volume (3D) enclosure.</p>"},{"location":"tutorial/test_computeBox/computeBox/#overview","title":"Overview","text":"<p>The API is organised into the following groups:</p> <ul> <li> <p>PCA-Aligned Oriented Bounding Boxes/Rectangles (2D &amp; 3D): </p> <p>Align the bounding shape with the principal components of the input points. Optionally, the computation can be carried out on the points\u2019 convex hull.</p> </li> <li> <p>Minimum Oriented Bounding Boxes/Rectangles (2D &amp; 3D): </p> <p>Compute the rectangle of smallest area (2D) or the box of smallest volume (3D) that encloses all points, using the rotating\u2011calipers algorithm in 2D and geometric optimisation in 3D.</p> </li> </ul>"},{"location":"tutorial/test_computeBox/computeBox/#2d-pca-aligned-oriented-bounding-rectangle","title":"2D PCA-Aligned Oriented Bounding Rectangle","text":""},{"location":"tutorial/test_computeBox/computeBox/#function-signature","title":"Function Signature","text":"<pre><code>// Matrix input\nstd::pair&lt;Eigen::Matrix&lt;double, 4, 2&gt;, Eigen::RowVector2d&gt; computePCAOBB2D(\n    const Eigen::MatrixX2d&amp; points,\n    bool useConvexHull = false\n);\n\n// Vector input\nstd::pair&lt;Eigen::Matrix&lt;double, 4, 2&gt;, Eigen::RowVector2d&gt; computePCAOBB2D(\n    const std::vector&lt;Eigen::RowVector2d&gt;&amp; points,\n    bool useConvexHull = false\n);\n</code></pre>"},{"location":"tutorial/test_computeBox/computeBox/#parameters","title":"Parameters","text":"<ul> <li> <p>points: Matrix of 2D points (<code>Eigen::MatrixX2d</code>, one point per row) or a <code>std::vector&lt;Eigen::RowVector2d&gt;</code>.</p> </li> <li> <p>useConvexHull (Default: <code>false</code>): If <code>true</code>, the convex hull is computed first and PCA is applied to the hull vertices.</p> </li> </ul>"},{"location":"tutorial/test_computeBox/computeBox/#return-value","title":"Return Value","text":"<ul> <li> <p>A <code>std::pair</code> containing:</p> <p>Vertices: <code>Eigen::Matrix&lt;double, 4, 2&gt;</code> \u2014 the four rectangle corners, listed counter\u2011clockwise.</p> <p>Centroid: <code>Eigen::RowVector2d</code> \u2014 the rectangle centre.</p> </li> </ul>"},{"location":"tutorial/test_computeBox/computeBox/#3d-pca-aligned-oriented-bounding-box","title":"3D PCA-Aligned Oriented Bounding Box","text":""},{"location":"tutorial/test_computeBox/computeBox/#function-signature_1","title":"Function Signature","text":"<pre><code>// Matrix input\nstd::pair&lt;Eigen::Matrix&lt;double, 8, 3&gt;, Eigen::RowVector3d&gt; computePCAOBB3D(\n    const Eigen::MatrixX3d&amp; points,\n    bool useConvexHull = false\n);\n\n// Vector input\nstd::pair&lt;Eigen::Matrix&lt;double, 8, 3&gt;, Eigen::RowVector3d&gt; computePCAOBB3D(\n    const std::vector&lt;Eigen::RowVector3d&gt;&amp; points,\n    bool useConvexHull = false\n);\n</code></pre>"},{"location":"tutorial/test_computeBox/computeBox/#parameters_1","title":"Parameters","text":"<ul> <li> <p>points: Matrix of 3D points (<code>Eigen::MatrixX3d</code>, one point per row) or a <code>std::vector&lt;Eigen::RowVector3d&gt;</code>.</p> </li> <li> <p>useConvexHull (Default: <code>false</code>): If <code>true</code>, the convex hull is computed first and PCA is applied to the hull vertices..</p> </li> </ul>"},{"location":"tutorial/test_computeBox/computeBox/#return-value_1","title":"Return Value","text":"<ul> <li> <p>A <code>std::pair</code> containing:</p> <p>Vertices: <code>Eigen::Matrix&lt;double, 8, 3&gt;</code> \u2014 the eight cuboid corners.</p> <p>Centroid: <code>Eigen::RowVector3d</code> \u2014 the cuboid centre.</p> </li> </ul>"},{"location":"tutorial/test_computeBox/computeBox/#2d-minimum-oriented-bounding-rectangle","title":"2D Minimum Oriented Bounding Rectangle","text":""},{"location":"tutorial/test_computeBox/computeBox/#function-signature_2","title":"Function Signature","text":"<pre><code>// Matrix input\nstd::pair&lt;Eigen::Matrix&lt;double, 4, 2&gt;, Eigen::RowVector2d&gt; computeMinOBB2D(\n    const Eigen::MatrixX2d&amp; points\n);\n\n// Vector input\nstd::pair&lt;Eigen::Matrix&lt;double, 4, 2&gt;, Eigen::RowVector2d&gt; computeMinOBB2D(\n    const std::vector&lt;Eigen::RowVector2d&gt;&amp; points\n);\n</code></pre>"},{"location":"tutorial/test_computeBox/computeBox/#parameters_2","title":"Parameters","text":"<ul> <li>points: Matrix of 2D points (<code>Eigen::MatrixX2d</code>, one point per row) or a <code>std::vector&lt;Eigen::RowVector2d&gt;</code>.</li> </ul>"},{"location":"tutorial/test_computeBox/computeBox/#return-value_2","title":"Return Value","text":"<ul> <li> <p>A <code>std::pair</code> containing:</p> <p>Vertices: <code>Eigen::Matrix&lt;double, 4, 2&gt;</code> \u2014 the four rectangle corners, listed counter\u2011clockwise.</p> <p>Centroid: <code>Eigen::RowVector2d</code> \u2014 the rectangle centre.</p> </li> </ul>"},{"location":"tutorial/test_computeBox/computeBox/#3d-minimum-oriented-bounding-box","title":"3D Minimum Oriented Bounding Box","text":""},{"location":"tutorial/test_computeBox/computeBox/#function-signature_3","title":"Function Signature","text":"<pre><code>// Matrix input\nstd::pair&lt;Eigen::Matrix&lt;double, 8, 3&gt;, Eigen::RowVector3d&gt; computeMinOBB3D(\n    const Eigen::MatrixX3d&amp; points\n);\n\n// Vector input\nstd::pair&lt;Eigen::Matrix&lt;double, 8, 3&gt;, Eigen::RowVector3d&gt; computeMinOBB3D(\n    const std::vector&lt;Eigen::RowVector3d&gt;&amp; points\n);\n</code></pre>"},{"location":"tutorial/test_computeBox/computeBox/#parameters_3","title":"Parameters","text":"<ul> <li>points: Matrix of 3D points (<code>Eigen::MatrixX3d</code>, one point per row) or a <code>std::vector&lt;Eigen::RowVector3d&gt;</code>.</li> </ul>"},{"location":"tutorial/test_computeBox/computeBox/#return-value_3","title":"Return Value","text":"<ul> <li> <p>A <code>std::pair</code> containing:</p> <p>Vertices: <code>Eigen::Matrix&lt;double, 8, 3&gt;</code> \u2014 the eight cuboid corners.</p> <p>Centroid: <code>Eigen::RowVector3d</code> \u2014 the cuboid centre.</p> </li> </ul>"},{"location":"tutorial/test_computeBox/computeBox/#example-usage","title":"Example Usage","text":"<p>The example below uses randomPoints.csv from the repository.</p>"},{"location":"tutorial/test_computeBox/computeBox/#1-data-preparation","title":"1. Data Preparation","text":"<p>Load 200 random 3D points from a CSV file into an Eigen matrix: <pre><code>Eigen::Matrix&lt;double, 200, 3&gt; testPointsMat;\nstd::ifstream file(\"./testData/randomPoints.csv\");\nstd::string line;\nEigen::Index row = 0;\nwhile (getline(file, line) &amp;&amp; row &lt; 200) {\n    std::istringstream lineStream(line);\n    std::string c1, c2, c3;\n    if (std::getline(lineStream, c1, ',') &amp;&amp;\n        std::getline(lineStream, c2, ',') &amp;&amp;\n        std::getline(lineStream, c3)) {\n\n        testPointsMat.row(row) &lt;&lt; stod(c1), stod(c2), stod(c3);\n        row++;\n    }\n}\n</code></pre></p> <p></p> \u00d7 \u00d7"},{"location":"tutorial/test_computeBox/computeBox/#2-running-the-bounding-box-algorithms","title":"2. Running the Bounding-Box Algorithms","text":"<p>With the data ready, compute both PCA-aligned and minimum-area/volume bounding shapes:</p> <pre><code>{\n    // 2D PCA Rectangle vs Minimum Rectangle\n    Eigen::Matrix&lt;double, 4, 2&gt; pcaRect = computePCAOBB2D(testPointsMat.leftCols&lt;2&gt;(), true).first;\n    Eigen::Matrix&lt;double, 4, 2&gt; mbRect = computeMinOBB2D(testPointsMat.leftCols&lt;2&gt;()).first;\n\n    std::cout &lt;&lt; \"\\n--- PCA 2D Bounding Rectangle (XY) ---\\n\";\n    std::cout &lt;&lt; pcaRect.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n\n    std::cout &lt;&lt; \"\\n--- Minimum 2D Bounding Rectangle (XY) ---\\n\";\n    std::cout &lt;&lt; mbRect.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n}\n\n{ \n    // 3D PCA Box vs Minimum Box\n    Eigen::Matrix&lt;double, 8, 3&gt; pcaBox = computePCAOBB3D(testPointsMat, true).first;\n    Eigen::Matrix&lt;double, 8, 3&gt; mbBox = computeMinOBB3D(testPointsMat).first;\n\n    std::cout &lt;&lt; \"\\n--- PCA 3D Bounding Box ---\\n\";\n    std::cout &lt;&lt; pcaBox.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n\n    std::cout &lt;&lt; \"\\n--- Minimum 3D Bounding Box ---\\n\";\n    std::cout &lt;&lt; mbBox.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n\n} \n</code></pre>"},{"location":"tutorial/test_computeBox/computeBox/#3-results","title":"3. Results","text":"<p>The figure below compares the two approaches:</p> \u00d7 <ul> <li>PCA\u2011aligned shapes typically enclose slightly more area or volume than the true minimum because they are restricted to the principal axes.</li> </ul> <p>\ud83d\udca1Tip: Use the PCA\u2011based OBB for its speed and suitability for large point clouds. Select the minimum\u2011area/volume OBB only when the exact smallest enclosure is required.</p>"},{"location":"tutorial/test_computeBox/computeBox/#complete-implementation","title":"Complete Implementation","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n\n    Eigen::Matrix&lt;double, 200, 3&gt; testPointsMat;\n    std::ifstream file(\"./testData/randomPoints.csv\");\n    std::string line;\n    Eigen::Index row = 0;\n    while (getline(file, line) &amp;&amp; row &lt; 200) {\n        std::istringstream lineStream(line);\n        std::string c1, c2, c3;\n        if (std::getline(lineStream, c1, ',') &amp;&amp;\n            std::getline(lineStream, c2, ',') &amp;&amp;\n            std::getline(lineStream, c3)) {\n\n            testPointsMat.row(row) &lt;&lt; stod(c1), stod(c2), stod(c3);\n            row++;\n        }\n    }\n\n    {\n        // 2D PCA Rectangle vs Minimum Rectangle\n        Eigen::Matrix&lt;double, 4, 2&gt; pcaRect = computePCAOBB2D(testPointsMat.leftCols&lt;2&gt;(), true).first;\n        Eigen::Matrix&lt;double, 4, 2&gt; mbRect = computeMinOBB2D(testPointsMat.leftCols&lt;2&gt;()).first;\n\n        std::cout &lt;&lt; \"\\n--- PCA 2D Bounding Rectangle (XY) ---\\n\";\n        std::cout &lt;&lt; pcaRect.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n\n        std::cout &lt;&lt; \"\\n--- Minimum 2D Bounding Rectangle (XY) ---\\n\";\n        std::cout &lt;&lt; mbRect.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n    }\n\n    { \n        // 3D PCA Box vs Minimum Box\n        Eigen::Matrix&lt;double, 8, 3&gt; pcaBox = computePCAOBB3D(testPointsMat, true).first;\n        Eigen::Matrix&lt;double, 8, 3&gt; mbBox = computeMinOBB3D(testPointsMat).first;\n\n        std::cout &lt;&lt; \"\\n--- PCA 3D Bounding Box ---\\n\";\n        std::cout &lt;&lt; pcaBox.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n\n        std::cout &lt;&lt; \"\\n--- Minimum 3D Bounding Box ---\\n\";\n        std::cout &lt;&lt; mbBox.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n\n    }   \n\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/test_computePlaneNormal/computePlaneNormal/","title":"computePlaneNormal","text":"<p>This document describes a function that calculates the unit normal vectors of a 3D plane defined by a set of coplanar points.</p>"},{"location":"tutorial/test_computePlaneNormal/computePlaneNormal/#function-signature","title":"Function Signature","text":"<pre><code>std::pair&lt;Eigen::RowVector3d, Eigen::RowVector3d&gt; computePlaneNormal(\n    const Eigen::MatrixX3d&amp; planePoints\n);\n</code></pre>"},{"location":"tutorial/test_computePlaneNormal/computePlaneNormal/#parameters","title":"Parameters","text":"<ul> <li>planePoints: Matrix of 3D points (<code>Eigen::MatrixX3d</code>), each row represents a point lying on the same plane. The matrix must contain at least three coplanar points.</li> </ul>"},{"location":"tutorial/test_computePlaneNormal/computePlaneNormal/#return-value","title":"Return Value","text":"<ul> <li> <p><code>std::pair&lt;Eigen::RowVector3d, Eigen::RowVector3d&gt;</code>:</p> <p>first: A unit normal vector perpendicular to the plane defined by <code>planePoints</code>.</p> <p>second: The opposite unit normal (the negation of the first).</p> </li> </ul>"},{"location":"tutorial/test_computePlaneNormal/computePlaneNormal/#example-usage","title":"Example Usage","text":"<p><pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n    Eigen::Matrix&lt;double,4,3&gt; Vertices;\n    Vertices &lt;&lt; 748694.4250704022, 2564734.3476669602, 49.5,\n        748674.4539194419, 2564739.5306861168, 81.5,\n        748674.4154279609, 2564734.5007915981, 49.5,\n        748694.4635618832, 2564739.3775614789, 81.5;\n\n    const auto&amp; [v1, v2] = computePlaneNormal(Vertices);\n    std::cout &lt;&lt; \"[computePlaneNormal] Result:\\n\";\n    std::cout &lt;&lt; \"  Normal Vector 1 (v1): \" &lt;&lt; v1.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  Normal Vector 2 (v2): \" &lt;&lt; v2.format(Eigen::FullPrecision) &lt;&lt; \"\\n\\n\";\n\n    return 0;\n}\n</code></pre> Visualization of the computed plane normals:</p> <p></p> \u00d7"},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/","title":"filterPointsByPolygon","text":"<p>Filters a set of 2D points according to their spatial relation to a polygon. You can keep or discard points that fall inside, outside, or exactly on the polygon boundary.</p>"},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#function-signature","title":"Function Signature","text":""},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#stdvectoreigenrowvector2d-filterpointsbypolygon-const-eigenmatrixx2d-polygonvertices-const-stdvectoreigenrowvector2d-points-bool-removeboundary-true-bool-removeinside-true-bool-needclosepolygon-true","title":"<pre><code> std::vector&lt;Eigen::RowVector2d&gt; filterPointsByPolygon(\n    const Eigen::MatrixX2d&amp; polygonVertices,\n    const std::vector&lt;Eigen::RowVector2d&gt;&amp; points,\n    bool removeBoundary = true,\n    bool removeInside = true,\n    bool needClosePolygon = true\n);\n</code></pre>","text":""},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#parameters","title":"Parameters","text":"Parameter Description <code>polygonVertices</code> <code>Eigen::MatrixX2d</code> \u2014 Each row is a vertex. If <code>needClosePolygon</code> is <code>true</code>, the vertices may be unordered or open; the function will sort them counter-clockwise and append the first vertex to close the loop. <code>points</code> <code>std::vector&lt;Eigen::RowVector2d&gt;</code> \u2014 the input points to filter. <code>removeBoundary</code> <code>bool</code> (default: <code>true</code>) \u2014 if <code>true</code>, removes points exactly on the polygon boundary; otherwise keeps them. <code>removeInside</code> <code>bool</code> (default: <code>true</code>) \u2014 if <code>true</code>, removes points strictly inside the polygon; otherwise keeps them. <code>needClosePolygon</code> <code>bool</code> (default: <code>true</code>) \u2014 <code>true</code> \u2192 auto-order &amp; close polygonVertices; <code>false</code> \u2192 assume vertices are already counter-clockwise and closed."},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#return-value","title":"Return Value","text":"<ul> <li>A <code>std::vector&lt;Eigen::RowVector2d&gt;</code> containing only those points that remain after filtering.</li> </ul>"},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#behavior","title":"Behavior","text":"removeInside removeBoundary Kept Points <code>false</code> <code>false</code> Keep inside &amp; boundary; remove outside <code>false</code> <code>true</code> Keep only inside; remove outside &amp; boundary <code>true</code> <code>false</code> Keep outside &amp; boundary; remove inside <code>true</code> <code>true</code> Keep only outside; remove inside &amp; boundary"},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#example-usage","title":"Example Usage","text":"<p>The following demo uses randomPoints.csv from the repository.</p>"},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#1-data-preparation","title":"1. Data Preparation","text":"<pre><code>std::vector&lt;Eigen::RowVector2d&gt; testPoints2D;\ntestPoints2D.reserve(200);\nstd::ifstream file(\"./testData/randomPoints.csv\");\nstd::string line;\nwhile (getline(file, line)) {\n    std::istringstream lineStream(line);\n    std::string c1, c2;\n    if (std::getline(lineStream, c1, ',') &amp;&amp;\n        std::getline(lineStream, c2, ',')) {\n\n        Eigen::RowVector2d vec2d;\n        vec2d &lt;&lt; stod(c1), stod(c2);\n        testPoints2D.emplace_back(vec2d);\n\n    }\n}\n\n// A simple quadrilateral\nEigen::Matrix&lt;double, 4, 2&gt; polygonVertices;\npolygonVertices &lt;&lt; 20.785733063246152, 76.974749045767595,\n    79.748658377982537, 77.104254429716875,\n    81.118930088650117, 18.361256017841775,\n    22.15600477391374, 18.231750633892496;\n</code></pre> \u00d7"},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#2-executing-the-filter","title":"2. Executing the Filter","text":"<pre><code>// Remove only boundary points, keep inside and outside:\nstd::vector&lt;Eigen::RowVector2d&gt; insidePoints2D = filterPointsByPolygon(\n    polygonVertices, testPoints2D,\n    /*removeBoundary=*/true,\n    /*removeInside=*/false,\n    /*needClosePolygon=*/true\n    );\nstd::cout &lt;&lt; \"\\nNumber of points outside the polygon: \" &lt;&lt; insidePoints2D.size() &lt;&lt; \"\\n\";\n\n// Remove inside and boundary, keep only outside:\nstd::vector&lt;Eigen::RowVector2d&gt; outsidePoints2D = filterPointsByPolygon(\n    polygonVertices, testPoints2D,\n    /*removeBoundary=*/true,\n    /*removeInside=*/true,\n    /*needClosePolygon=*/true\n    );\nstd::cout &lt;&lt; \"\\nNumber of points inside the polygon: \" &lt;&lt; outsidePoints2D.size() &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#3-results","title":"3. Results","text":"\u00d7"},{"location":"tutorial/test_filterPointsByPolygon/filterPointsByPolygon/#complete-implementation","title":"Complete Implementation","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n\n    std::vector&lt;Eigen::RowVector2d&gt; testPoints2D;\n    testPoints2D.reserve(200);\n    std::ifstream file(\"./testData/randomPoints.csv\");\n    std::string line;\n    while (getline(file, line)) {\n        std::istringstream lineStream(line);\n        std::string c1, c2;\n        if (std::getline(lineStream, c1, ',') &amp;&amp;\n            std::getline(lineStream, c2, ',')) {\n\n            Eigen::RowVector2d vec2d;\n            vec2d &lt;&lt; stod(c1), stod(c2);\n            testPoints2D.emplace_back(vec2d);\n\n        }\n    }\n\n    Eigen::Matrix&lt;double, 4, 2&gt; polygonVertices;\n    polygonVertices &lt;&lt; 20.785733063246152, 76.974749045767595,\n        79.748658377982537, 77.104254429716875,\n        81.118930088650117, 18.361256017841775,\n        22.15600477391374, 18.231750633892496;\n\n    std::vector&lt;Eigen::RowVector2d&gt; insidePoints2D = filterPointsByPolygon(\n        polygonVertices, testPoints2D,\n        /*removeBoundary=*/true,\n        /*removeInside=*/false,\n        /*needClosePolygon=*/true\n        );\n    std::cout &lt;&lt; \"\\nNumber of points outside the polygon: \" &lt;&lt; insidePoints2D.size() &lt;&lt; \"\\n\";\n\n    std::vector&lt;Eigen::RowVector2d&gt; outsidePoints2D = filterPointsByPolygon(\n        polygonVertices, testPoints2D,\n        /*removeBoundary=*/true,\n        /*removeInside=*/true,\n        /*needClosePolygon=*/true\n        );\n    std::cout &lt;&lt; \"\\nNumber of points inside the polygon: \" &lt;&lt; outsidePoints2D.size() &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/","title":"filterPointsByPolyhedron","text":"<p>Filters a set of 3D points according to their spatial relationship to a polyhedron.  Depending on the specified options, points located inside, outside, or exactly on the polyhedron\u2019s faces can be either retained or discarded.</p>"},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#function-signature","title":"Function Signature","text":""},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#stdvectoreigenrowvector3d-filterpointsbypolyhedron-const-eigenmatrixx3d-polyhedronvertices-const-stdvectoreigenrowvector3d-points-bool-removeboundary-true-bool-removeinside-true","title":"<pre><code>std::vector&lt;Eigen::RowVector3d&gt; filterPointsByPolyhedron(\n    const Eigen::MatrixX3d&amp; polyhedronVertices,\n    const std::vector&lt;Eigen::RowVector3d&gt;&amp; points,\n    bool removeBoundary = true,\n    bool removeInside = true\n);\n</code></pre>","text":""},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#parameters","title":"Parameters","text":"Parameter Description <code>polyhedronVertices</code> <code>Eigen::MatrixX3d</code> \u2014 each row specifies the coordinates of a vertex of the polyhedron. <code>points</code> <code>std::vector&lt;Eigen::RowVector3d&gt;</code> \u2014 the 3D points to be filtered. <code>removeBoundary</code> <code>bool</code> (default: <code>true</code>) \u2014 if <code>true</code>, points lying exactly on the polyhedron\u2019s surface are discarded; otherwise they are kept. <code>removeInside</code> <code>bool</code> (default: <code>true</code>) \u2014 if <code>true</code>, points strictly inside the polyhedron are discarded; otherwise they are kept."},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#return-value","title":"Return Value","text":"<ul> <li><code>std::vector&lt;Eigen::RowVector3d&gt;</code> \u2014 the subset of points that satisfy the filtering criteria..</li> </ul>"},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#behavior","title":"Behavior","text":"removeInside removeBoundary Kept Points <code>false</code> <code>false</code> Inside &amp; boundary; removes only points outside <code>false</code> <code>true</code> Inside only; removes boundary &amp; outside <code>true</code> <code>false</code> Outside &amp; boundary; removes only points inside <code>true</code> <code>true</code> Outside only; removes inside &amp; boundary"},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#example-usage","title":"Example Usage","text":"<p>The following example uses randomPoints.csv from the repository.</p>"},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#1-data-preparation","title":"1. Data Preparation","text":"<pre><code>std::vector&lt;Eigen::RowVector3d&gt; testPoints3D;\ntestPoints3D.reserve(200);\nstd::ifstream file(\"./testData/randomPoints.csv\");\nstd::string line;\nwhile (getline(file, line)) {\n    std::istringstream lineStream(line);\n    std::string c1, c2, c3;\n    if (std::getline(lineStream, c1, ',') &amp;&amp;\n        std::getline(lineStream, c2, ',') &amp;&amp;\n        std::getline(lineStream, c3)) {\n\n        Eigen::RowVector3d vec3d;\n        vec3d &lt;&lt; stod(c1), stod(c2), stod(c3);\n        testPoints3D.emplace_back(vec3d);\n\n    }\n}\n\nEigen::Matrix&lt;double, 8, 3&gt; polyhedronVertices;\npolyhedronVertices &lt;&lt; 20.785733063246152, 76.974749045767595, 20.082613534316067,\n    79.748658377982537, 77.104254429716875, 20.082613534316067,\n    81.118930088650117, 18.361256017841775, 20.082613534316067,\n    22.15600477391374, 18.231750633892496, 20.082613534316067,\n    20.785733063246152, 76.974749045767595, 80.113871877439578,\n    79.748658377982537, 77.104254429716875, 80.113871877439578,\n    81.118930088650117, 18.361256017841775, 80.113871877439578,\n    22.15600477391374, 18.231750633892496, 80.113871877439578;\n</code></pre> \u00d7"},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#2-executing-the-filter","title":"2. Executing the Filter","text":"<pre><code>std::vector&lt;Eigen::RowVector3d&gt; insidePoints3D = filterPointsByPolyhedron(\n    polyhedronVertices, testPoints3D,\n    /*removeBoundary=*/false,\n    /*removeInside=*/false\n    );\nstd::cout &lt;&lt; \"\\nNumber of points inside the polyhedron: \" &lt;&lt; insidePoints3D.size() &lt;&lt; \"\\n\";\n\nstd::vector&lt;Eigen::RowVector3d&gt; outsidePoints3D = filterPointsByPolyhedron(\n    polyhedronVertices, testPoints3D,\n    /*removeBoundary=*/false,\n    /*removeInside=*/true\n    );\nstd::cout &lt;&lt; \"\\nNumber of points outside the polyhedron: \" &lt;&lt; outsidePoints3D.size() &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#3-results","title":"3. Results","text":"\u00d7"},{"location":"tutorial/test_filterPointsByPolyhedron/filterPointsByPolyhedron/#complete-implementation","title":"Complete Implementation","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n\n    std::vector&lt;Eigen::RowVector3d&gt; testPoints3D;\n    testPoints3D.reserve(200);\n    std::ifstream file(\"./testData/randomPoints.csv\");\n    std::string line;\n    while (getline(file, line)) {\n        std::istringstream lineStream(line);\n        std::string c1, c2, c3;\n        if (std::getline(lineStream, c1, ',') &amp;&amp;\n            std::getline(lineStream, c2, ',') &amp;&amp;\n            std::getline(lineStream, c3)) {\n\n            Eigen::RowVector3d vec3d;\n            vec3d &lt;&lt; stod(c1), stod(c2), stod(c3);\n            testPoints3D.emplace_back(vec3d);\n\n        }\n    }\n\n    Eigen::Matrix&lt;double, 8, 3&gt; polyhedronVertices;\n    polyhedronVertices &lt;&lt; 20.785733063246152, 76.974749045767595, 20.082613534316067,\n        79.748658377982537, 77.104254429716875, 20.082613534316067,\n        81.118930088650117, 18.361256017841775, 20.082613534316067,\n        22.15600477391374, 18.231750633892496, 20.082613534316067,\n        20.785733063246152, 76.974749045767595, 80.113871877439578,\n        79.748658377982537, 77.104254429716875, 80.113871877439578,\n        81.118930088650117, 18.361256017841775, 80.113871877439578,\n        22.15600477391374, 18.231750633892496, 80.113871877439578;\n\n\n    std::vector&lt;Eigen::RowVector3d&gt; insidePoints3D = filterPointsByPolyhedron(\n        polyhedronVertices, testPoints3D,\n        /*removeBoundary=*/false,\n        /*removeInside=*/false\n        );\n    std::cout &lt;&lt; \"\\nNumber of points inside the polyhedron: \" &lt;&lt; insidePoints3D.size() &lt;&lt; \"\\n\";\n\n    std::vector&lt;Eigen::RowVector3d&gt; outsidePoints3D = filterPointsByPolyhedron(\n        polyhedronVertices, testPoints3D,\n        /*removeBoundary=*/false,\n        /*removeInside=*/true\n        );\n    std::cout &lt;&lt; \"\\nNumber of points outside the polyhedron: \" &lt;&lt; outsidePoints3D.size() &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/test_generateClosedPolygon/generateClosedPolygon/","title":"generateClosedPolygon","text":"<p>Generates a closed polygon from an unordered set of 2D points or coplanar 3D points.  </p>"},{"location":"tutorial/test_generateClosedPolygon/generateClosedPolygon/#function-signature","title":"Function Signature","text":"<pre><code>Eigen::MatrixXd generateClosedPolygon(\n    const Eigen::MatrixXd&amp; polygonVertices\n);\n</code></pre>"},{"location":"tutorial/test_generateClosedPolygon/generateClosedPolygon/#parameters","title":"Parameters","text":"<ul> <li>polygonVertices:   An <code>Eigen::MatrixXd</code> of size <code>N\u00d72</code> (for 2D) or <code>N\u00d73</code> (for coplanar 3D), representing the unordered vertices of the polygon.</li> </ul>"},{"location":"tutorial/test_generateClosedPolygon/generateClosedPolygon/#return-value","title":"Return Value","text":"<ul> <li>An <code>Eigen::MatrixXd</code> containing the input vertices reordered in counter-clockwise sequence, with the first vertex repeated at the end to close the loop.</li> </ul>"},{"location":"tutorial/test_generateClosedPolygon/generateClosedPolygon/#example-usage","title":"Example Usage","text":""},{"location":"tutorial/test_generateClosedPolygon/generateClosedPolygon/#1-define-unordered-points","title":"1. Define Unordered Points","text":"<pre><code>Eigen::Matrix&lt;double,4,3&gt; unorderedVertices;\nunorderedVertices &lt;&lt; 748694.4250704022, 2564734.3476669602, 49.5,\n    748674.4539194419, 2564739.5306861168, 81.5,\n    748674.4154279609, 2564734.5007915981, 49.5,\n    748694.4635618832, 2564739.3775614789, 81.5;\n</code></pre> <p>If you connect these points in their given order, you obtain an open, zig-zag path rather than a closed polygon.</p> <p></p> \u00d7"},{"location":"tutorial/test_generateClosedPolygon/generateClosedPolygon/#2-executing-the-function","title":"2. Executing the Function","text":"<p>Call the function to compute the centroid, sort the points, and close the polygon:</p> <pre><code>Eigen::MatrixX3d polygon = generateClosedPolygon(unorderedVertices);\n</code></pre> <p>After the call, <code>polygon</code> contains the vertices in counter-clockwise order, with the first point repeated at the end to form a closed loop:</p> \u00d7"},{"location":"tutorial/test_generateClosedPolygon/generateClosedPolygon/#complete-implementation","title":"Complete Implementation","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n\n    Eigen::Matrix&lt;double,4,3&gt; unorderedVertices;\n    unorderedVertices &lt;&lt; 748694.4250704022, 2564734.3476669602, 49.5,\n        748674.4539194419, 2564739.5306861168, 81.5,\n        748674.4154279609, 2564734.5007915981, 49.5,\n        748694.4635618832, 2564739.3775614789, 81.5;\n\n    Eigen::MatrixX3d polygon = generateClosedPolygon(unorderedVertices);\n    std::cout &lt;&lt; \"[Input] Original unordered vertices (n x 3):\\n\";\n    std::cout &lt;&lt; unorderedVertices.format(Eigen::FullPrecision) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"[Output] Generated closed polygon (n x 3):\\n\";\n    std::cout &lt;&lt; polygon.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/test_isCoplanar/isCoplanar/","title":"isCoplanar","text":"<p>Checks whether a set of 3D points lies on the same plane.</p>"},{"location":"tutorial/test_isCoplanar/isCoplanar/#function-signatures","title":"Function Signatures","text":"<pre><code>bool isCoplanar(const Eigen::MatrixX3d&amp; points);\n</code></pre>"},{"location":"tutorial/test_isCoplanar/isCoplanar/#parameters","title":"Parameters","text":"<ul> <li>points: Matrix of 3D points (<code>Eigen::MatrixX3d</code>, one point per row).</li> </ul>"},{"location":"tutorial/test_isCoplanar/isCoplanar/#return-value","title":"Return Value","text":"<ul> <li><code>true</code> if all points are coplanar; otherwise, <code>false</code>.</li> </ul>"},{"location":"tutorial/test_isCoplanar/isCoplanar/#example-usage","title":"Example Usage","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n    Eigen::Matrix&lt;double, 5, 3&gt; points1;\n    points1 &lt;&lt; \n        0.0,   0.0,   0.5,\n        0.0,   1.0,   0.5,\n        1.0,   1.0,   0.5,\n        1.0,   0.0,   0.5,\n        0.5,   0.5,   1.0;\n\n    bool isCoplanar1  = isCoplanar(points1);\n    std::cout &lt;&lt; \"Test Case 1 (points1): \";\n    if (isCoplanar1) {\n        std::cout &lt;&lt; \"coplanar\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"not coplanar\" &lt;&lt; std::endl;\n    }\n\n    Eigen::Matrix&lt;double, 5, 3&gt; points2;\n    points2 &lt;&lt; \n        0.0,   0.0,   0.5,\n        0.0,   1.0,   0.5,\n        1.0,   1.0,   0.5,\n        1.0,   0.0,   0.5,\n        0.5,   0.5,   0.5;\n\n    bool isCoplanar2 = isCoplanar(points2);\n    std::cout &lt;&lt; \"Test Case 2 (points2): \";\n    if (isCoplanar2) {\n        std::cout &lt;&lt; \"coplanar\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"not coplanar\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>The following illustration shows the two test cases: </p> <ul> <li>left: a non-coplanar set of points</li> <li>right: a coplanar configuration.</li> </ul> <p></p> \u00d7"},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/","title":"isLinePolygonIntersection (2D &amp; 3D)","text":"<p>Determine whether a line primitive (segment, ray, or infinite line) intersects a polygon in 2D or 3D space.</p>"},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/#2d-intersection","title":"2D Intersection","text":""},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/#function-signatures","title":"Function Signatures","text":"<pre><code>// Returns true if geoAB intersects the polygon. Optionally outputs all intersection points.\ntemplate&lt;typename LineT&gt;\nbool isLinePolygonIntersection2D(\n    const Eigen::MatrixX2d&amp; polygonVertices,\n    const LineT&amp; geoAB,\n    std::vector&lt;Eigen::RowVector2d&gt;&amp; intersections,\n    bool needClosePolygon = true\n);\n\n// Overload that does not compute intersection coordinates..\ntemplate&lt;typename LineT&gt;\nbool isLinePolygonIntersection2D(\n    const Eigen::MatrixX2d&amp; polygonVertices,\n    const LineT&amp; geoAB,\n    bool needClosePolygon = true\n);\n</code></pre>"},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/#parameters","title":"Parameters","text":"<ul> <li> <p><code>polygonVertices</code> (<code>Eigen::MatrixX2d</code>):</p> <ul> <li>Each row is a 2D vertex (<code>N\u00d72</code>).</li> <li>If <code>needClosePolygon</code> is <code>true</code>, the vertices are automatically ordered counter-clockwise, and the first vertex is appended to close the loop.</li> </ul> </li> <li> <p><code>geoAB</code> (<code>LineT</code>): 2D line primitive (<code>Segment2D</code>, <code>Ray2D</code>, <code>Line2D</code>).</p> </li> <li><code>intersections</code> (<code>std::vector&lt;Eigen::RowVector2d&gt;&amp;</code>): If provided, receives all intersection points.</li> <li><code>needClosePolygon</code> (<code>bool</code>, default <code>true</code>): <ul> <li><code>false</code>: <code>polygonVertices</code> must already form an ordered, closed polygon.</li> <li><code>true</code>: the function will sort and close the polygon for you.</li> </ul> </li> </ul>"},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/#return-value","title":"Return Value","text":"<ul> <li><code>true</code> if at least one intersection exists; otherwise <code>false</code>.</li> </ul>"},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/#3d-intersection","title":"3D Intersection","text":""},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/#function-signatures_1","title":"Function Signatures","text":"<pre><code>// Returns true if geoAB intersects the coplanar 3D polygon, and fills intersections.\ntemplate&lt;typename LineT&gt;\nbool isLinePolygonIntersection3D(\n    const Eigen::MatrixX3d&amp; polygonVertices,\n    const LineT&amp; geoAB,\n    std::vector&lt;Eigen::RowVector3d&gt;&amp; intersections,  \n    bool checkBoundary,                             \n    bool needClosePolygon                          \n);\n\n// Overload without collecting intersection coordinates.\ntemplate&lt;typename LineT&gt;\nbool isLinePolygonIntersection3D(\n    const Eigen::MatrixX3d&amp; polygonVertices,\n    const LineT&amp; geoAB,\n    bool checkBoundary,\n    bool needClosePolygon\n);\n</code></pre>"},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/#parameters_1","title":"Parameters","text":"<ul> <li> <p><code>polygonVertices</code> (<code>Eigen::MatrixX3d</code>):</p> <ul> <li>Each row is a coplanar 3-D vertex (<code>N\u00d73</code>).</li> <li>If <code>needClosePolygon</code> is <code>true</code>, the vertices are automatically ordered counter-clockwise, and the first vertex is appended to close the loop.</li> </ul> </li> <li> <p><code>geoAB</code> (<code>LineT</code>): 3D line primitive (<code>Segment2D</code>, <code>Ray2D</code>, <code>Line2D</code>).</p> </li> <li><code>intersections</code> (<code>std::vector&lt;Eigen::RowVector3d&gt;&amp;</code>): Collected 3D intersection points.</li> <li><code>checkBoundary</code> (<code>bool</code>, default <code>true</code>): If <code>true</code>, intersections on the polygon edges count; otherwise only strictly interior intersections.</li> <li><code>needClosePolygon</code> (<code>bool</code>, default <code>true</code>): Same semantics as in the 2D version..</li> </ul>"},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/#return-value_1","title":"Return Value","text":"<ul> <li><code>true</code> if there is at least one intersection; otherwise <code>false</code>.</li> </ul>"},{"location":"tutorial/test_isLinePolygonIntersection/isLinePolygonIntersection/#example-usage","title":"Example Usage","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n\n    Eigen::Matrix&lt;double,4,3&gt; unorderedVertices;\n    unorderedVertices &lt;&lt; 748694.4250704022, 2564734.3476669602, 49.5,\n        748674.4539194419, 2564739.5306861168, 81.5,\n        748674.4154279609, 2564734.5007915981, 49.5,\n        748694.4635618832, 2564739.3775614789, 81.5;\n\n    Eigen::MatrixX3d polygon = generateClosedPolygon(unorderedVertices);\n\n    Eigen::RowVector3d A(748674.6211, 2564712.4947, 64.5593);\n    Eigen::RowVector3d B(748691.5686, 2564750.4571, 61.6250);\n    Segment3D AB{ A ,B };\n    std::vector&lt;Eigen::RowVector3d&gt; intersections1;\n    bool isIntersection1 = isLinePolygonIntersection3D(polygon, AB, intersections1, true, false);\n    std::cout &lt;&lt; \"\\n-- Segment AB Intersection --\\n\";\n    if (isIntersection1) {\n        std::cout &lt;&lt; \"Intersection Points:\\n\"\n                    &lt;&lt; intersections1[0].format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n    }\n\n    std::cout &lt;&lt; \"\\n--------------------------------------------------------\\n\";\n\n    Eigen::RowVector3d C(748705.94909344427, 2564736.774573423, 65.5);\n    Eigen::RowVector3d D(748697.44422830443, 2564736.8396572643, 65.5);\n    Ray3D CD{ C ,D };\n    std::vector&lt;Eigen::RowVector3d&gt; intersections2;\n    bool isIntersection2 = isLinePolygonIntersection3D(polygon, CD, intersections2, true, false);\n    std::cout &lt;&lt; \"\\n-- Ray CD Intersection --\\n\";\n    if (isIntersection2) {\n        std::cout &lt;&lt; \"Intersection Points:\\n\";\n        for (const auto&amp; point : intersections2) {\n            std::cout &lt;&lt; point.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n        }\n    }\n\n    return 0;\n}\n</code></pre> <p>The figure below visualizes the intersection points between the line primitives (segment and ray) and the 3D polygon.</p> <p></p> \u00d7"},{"location":"tutorial/test_isLinePolyhedronIntersection/isLinePolyhedronIntersection/","title":"isLinePolyhedronIntersection","text":"<p>Determine whether a 3D line primitive (segment, ray, or infinite line) intersects a polyhedron.</p>"},{"location":"tutorial/test_isLinePolyhedronIntersection/isLinePolyhedronIntersection/#function-signatures","title":"Function Signatures","text":"<pre><code>// Test intersection and collect all intersection points.\ntemplate&lt;typename LineT&gt;\nbool isLinePolyhedronIntersection(\n    const Eigen::MatrixX3d&amp; polyhedronVertices,\n    const LineT&amp; geoAB,\n    std::vector&lt;Eigen::RowVector3d&gt;&amp; intersections\n)\n\n// Overload without computing intersection coordinates.\ntemplate&lt;typename LineT&gt;\nbool isLinePolyhedronIntersection(\n    const Eigen::MatrixX3d&amp; polyhedronVertices,\n    const LineT&amp; geoAB\n)\n</code></pre>"},{"location":"tutorial/test_isLinePolyhedronIntersection/isLinePolyhedronIntersection/#parameters","title":"Parameters","text":"<ul> <li>polyhedronVertices (<code>Eigen::MatrixX3d</code>):    Matrix of size <code>N\u00d73</code>; each row represents a vertex of the polyhedron. Vertices may be unordered or unclosed.</li> <li>geoAB (<code>LineT</code>):   The 3D line primitive (e.g., <code>Segment3D</code>, <code>Ray3D</code>, <code>Line3D</code>) to check for intersection with the polyhedron.</li> <li>intersections (<code>std::vector&lt;Eigen::RowVector3d&gt;&amp;</code>):   If provided, receives all computed intersection points..</li> </ul>"},{"location":"tutorial/test_isLinePolyhedronIntersection/isLinePolyhedronIntersection/#return-value","title":"Return Value","text":"<ul> <li><code>true</code> if there is at least one intersection; otherwise returns <code>false</code>.</li> </ul>"},{"location":"tutorial/test_isLinePolyhedronIntersection/isLinePolyhedronIntersection/#example-usage","title":"Example Usage","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n\n    Eigen::Matrix&lt;double, 8, 3&gt; polyhedronVertices;\n    polyhedronVertices &lt;&lt; 748674.4539194419, 2564739.5306861168, 49,\n           748694.4635618832, 2564739.3775614789, 49,\n           748694.42507040221, 2564734.3476669602, 49,\n           748674.41542796092, 2564734.5007915981, 49,\n           748674.4539194419, 2564739.5306861168, 81,\n           748694.4635618832, 2564739.3775614789, 81,\n           748694.42507040221, 2564734.3476669602, 81,\n           748674.41542796092, 2564734.5007915981, 81;\n    {\n        Eigen::RowVector3d A(748674.6211, 2564712.4947, 64.5593);\n        Eigen::RowVector3d B(748708.8839, 2564753.8769, 59.6075);\n        Segment3D AB{ A ,B };\n        std::vector&lt;Eigen::RowVector3d&gt; intersections;\n        bool isIntersection = isLinePolyhedronIntersection(testPolyhedron, AB, intersections);\n        std::cout &lt;&lt; \"\\n-- Segment AB Intersection with Polyhedron --\\n\";\n        if (isIntersection) {\n            std::cout &lt;&lt; \"Intersection Points:\\n\";\n            for (const auto&amp; point : intersections) {\n                std::cout &lt;&lt; point.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n            }\n        }\n    }\n    std::cout &lt;&lt; \"\\n--------------------------------\\n\";\n    {\n        Eigen::RowVector3d A(748674.6211, 2564712.4947, 64.5593);\n        Eigen::RowVector3d B(748680.9715683657, 2564720.1647197301, 63.641504336681471);\n        Ray3D AB{ A, B };\n        std::vector&lt;Eigen::RowVector3d&gt; intersections;\n        std::cout &lt;&lt; \"\\n-- Ray AB Intersection with Polyhedron --\\n\";\n        bool isIntersection = isLinePolyhedronIntersection(testPolyhedron, AB, intersections);\n        if (isIntersection) {\n            std::cout &lt;&lt; \"Intersection Points:\\n\";\n            for (const auto&amp; point : intersections) {\n                std::cout &lt;&lt; point.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre> \u00d7"},{"location":"tutorial/test_isLinesIntersection/computeLinesDistance/","title":"computeLinesDistance","text":"<p>Computes the closest points and shortest distance between two 3D line primitives (segments, rays, or infinite lines).</p>"},{"location":"tutorial/test_isLinesIntersection/computeLinesDistance/#overview","title":"Overview","text":"<p>Supports <code>Segment3D</code>, <code>Ray3D</code>, and <code>Line3D</code>. Each type must expose <code>P1</code> and <code>P2</code> members of type <code>Eigen::RowVector3d</code>, representing its endpoints.</p>"},{"location":"tutorial/test_isLinesIntersection/computeLinesDistance/#function-signatures","title":"Function Signatures","text":"<pre><code>template&lt;typename LineT&gt;\nstd::tuple&lt;Eigen::RowVector3d, Eigen::RowVector3d, double&gt; computeLinesDistance(\n    const LineT&amp; geoAB, const LineT&amp; geoCD)\uff1b\n</code></pre>"},{"location":"tutorial/test_isLinesIntersection/computeLinesDistance/#parameters","title":"Parameters","text":"<ul> <li> <p>geoAB (<code>LineT</code>): The first 3D line primitive (e.g., <code>Segment3D</code>, <code>Ray3D</code>, <code>Line3D</code>). Must provide members <code>P1</code> and <code>P2</code> of type <code>Eigen::RowVector3d</code>.</p> </li> <li> <p>geoCD (<code>LineT</code>): The second 3D line primitive, with the same requirements as <code>geoAB</code>.</p> </li> </ul>"},{"location":"tutorial/test_isLinesIntersection/computeLinesDistance/#return-value","title":"Return Value","text":"<p>A <code>std::tuple</code> containing:</p> <ol> <li>Closest point on geoAB (<code>Eigen::RowVector3d</code>).</li> <li>Closest point on geoCD (<code>Eigen::RowVector3d</code>).</li> <li>Shortest distance between the two line primitives (<code>double</code>).</li> </ol>"},{"location":"tutorial/test_isLinesIntersection/computeLinesDistance/#example-usage","title":"Example Usage","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n    {\n        Eigen::RowVector3d A(1, 1, 0);\n        Eigen::RowVector3d B(0, -1, 0.4);\n        Eigen::RowVector3d C(1, -1, 0);\n        Eigen::RowVector3d D(0, 0, 0.5);\n        Segment3D AB{ A ,B };\n        Segment3D CD{ C ,D };\n        const auto&amp; [closestP1, closestP2, dist] = computeLinesDistance(AB, CD);\n        std::cout &lt;&lt; \"Closest Point on Segment AB: \" &lt;&lt; closestP1.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"Closest Point on Segment CD: \" &lt;&lt; closestP2.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"Distance: \" &lt;&lt; dist &lt;&lt; \"\\n\";\n    }\n\n    {\n        Eigen::RowVector3d A(1, 1, 0);\n        Eigen::RowVector3d B(0, 0.5, 0.55);\n        Eigen::RowVector3d C(1, -1, 0);\n        Eigen::RowVector3d D(0, 0, 0.45);\n        Ray3D AB{ A ,B };\n        Ray3D CD{ C ,D };\n        std::tuple&lt;Eigen::RowVector3d, Eigen::RowVector3d, double&gt; Intersection;\n        const auto&amp; [closestP1, closestP2, dist] = computeLinesDistance(AB, CD);\n        std::cout &lt;&lt; \"Closest Point on Ray AB: \" &lt;&lt; closestP1.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"Closest Point on Ray CD: \" &lt;&lt; closestP2.format(Eigen::FullPrecision) &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"Distance: \" &lt;&lt; dist &lt;&lt; \"\\n\";\n    }\n\n    return 0;\n}\n</code></pre> \u00d7"},{"location":"tutorial/test_isLinesIntersection/isLinesIntersection/","title":"isLinesIntersection (2D &amp; 3D)","text":"<p>Functions that test whether two line primitives (segments, rays, or infinite lines) intersect in 2D or 3D space.</p>"},{"location":"tutorial/test_isLinesIntersection/isLinesIntersection/#function-signatures","title":"Function Signatures","text":""},{"location":"tutorial/test_isLinesIntersection/isLinesIntersection/#2d-intersection","title":"2D Intersection","text":"<pre><code>template&lt;typename LineT&gt;\n// Check intersection and optionally retrieve the intersection point.\nbool isLinesIntersection2D(\n    const LineT&amp; geoAB,\n    const LineT&amp; geoCD,\n    Eigen::RowVector2d&amp; intersection\n);\n\n// Overload without retrieving the intersection point. \ntemplate&lt;typename LineT&gt;\nbool isLinesIntersection2D(\n    const LineT&amp; geoAB,\n    const LineT&amp; geoCD\n);\n</code></pre>"},{"location":"tutorial/test_isLinesIntersection/isLinesIntersection/#parameters","title":"Parameters","text":"<ul> <li> <p>geoAB: The first 2D line primitive (e.g., <code>Segment2D</code>, <code>Ray2D</code>, <code>Line2D</code>). Must provide members <code>P1</code> and <code>P2</code> of type <code>Eigen::RowVector2d</code>.</p> </li> <li> <p>geoCD: The second 2D line primitive, with the same requirements as <code>geoAB</code>.</p> </li> <li> <p>intersection: (Optional) If the line primitives intersect, receives the intersection point.</p> </li> </ul>"},{"location":"tutorial/test_isLinesIntersection/isLinesIntersection/#return-value","title":"Return Value","text":"<ul> <li><code>true</code> if the two line primitives intersect; otherwise, <code>false</code>.</li> </ul>"},{"location":"tutorial/test_isLinesIntersection/isLinesIntersection/#3d-intersection","title":"3D Intersection","text":"<pre><code>// Check intersection within a distance threshold and retrieve the closest points.\ntemplate&lt;typename T1, typename T2&gt;\nbool isLinesIntersection3D(\n    const T1&amp; geoAB,\n    const T2&amp; geoCD,\n    std::tuple&lt;Eigen::RowVector3d, Eigen::RowVector3d, double&gt;&amp; output,\n    double threshold\n);\n\n// Overload without retrieving the intersection point.\ntemplate&lt;typename T1, typename T2&gt;\nbool isLinesIntersection3D(\n    const T1&amp; geoAB,\n    const T2&amp; geoCD,\n    double threshold\n);\n</code></pre>"},{"location":"tutorial/test_isLinesIntersection/isLinesIntersection/#parameters-3d-version","title":"Parameters (3D Version)","text":"Parameter Type Description <code>geoAB</code> Any 3D line primitive (e.g., <code>Segment3D</code>, <code>Ray3D</code>, <code>Line3D</code>) with <code>P1</code>, <code>P2</code> of type <code>Eigen::RowVector3d</code>. First line/ray/segment. <code>geoCD</code> Same as <code>geoAB</code>. Second line/ray/segment. <code>output</code> <code>std::tuple&lt;Eigen::RowVector3d, Eigen::RowVector3d, double&gt;</code> (optional) If the line primitives intersect, this parameter will hold the closest points and the distance. <code>threshold</code> <code>double</code> The maximum distance for which the line primitives are considered to intersect (only for 3D versions)."},{"location":"tutorial/test_isLinesIntersection/isLinesIntersection/#return-value_1","title":"Return Value","text":"<ul> <li><code>true</code> if the minimum distance between the two line primitives is \u2264 <code>threshold</code>; otherwise <code>false</code>.</li> </ul>"},{"location":"tutorial/test_isLinesIntersection/isLinesIntersection/#example-usage","title":"Example Usage","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n    // Define the endpoints of two 3D segments\n    Eigen::RowVector3d A(1, 1, 0);\n    Eigen::RowVector3d B(0, -1, 0.4);\n    Eigen::RowVector3d C(1, -1, 0);\n    Eigen::RowVector3d D(0, 0, 0.5);\n    Segment3D AB{ A ,B };\n    Segment3D CD{ C ,D };\n\n    // Tuple to hold the closest points and their distance\n    std::tuple&lt;Eigen::RowVector3d, Eigen::RowVector3d, double&gt; intersectionInfo;\n\n    // Test 1: threshold = 0.01\n    bool intersects1 = isLinesIntersection3D(AB, CD, intersectionInfo, 0.01);\n\n    // Test 2: threshold = 0.1\n    bool intersects2 = isLinesIntersection3D(AB, CD, intersectionInfo, 0.1);\n\n    return 0;\n}\n</code></pre> <p>The minimum distance between segments AB and CD is 0.0604.</p> <p>Left: with <code>threshold = 0.01</code>, the segments are considered non-intersecting.</p> <p>Right: with <code>threshold = 0.1</code>, they are considered intersecting.</p> <p></p> \u00d7"},{"location":"tutorial/test_isPointInPolygon/isPointInPolygon/","title":"isPointInPolygon (2D &amp; 3D)","text":"<p>These functions determine whether a point lies inside or on the boundary of a polygon in 2D or 3D space.</p>"},{"location":"tutorial/test_isPointInPolygon/isPointInPolygon/#function-signatures","title":"Function Signatures","text":""},{"location":"tutorial/test_isPointInPolygon/isPointInPolygon/#2d-version","title":"2D Version","text":"<pre><code>bool isPointInPolygon2D(\n    const Eigen::MatrixX2d&amp; polygonVertices,\n    const Eigen::RowVector2d&amp; point,\n    bool checkBoundary = true,\n    bool needClosePolygon = true\n);\n</code></pre>"},{"location":"tutorial/test_isPointInPolygon/isPointInPolygon/#3d-version","title":"3D Version","text":"<pre><code>bool isPointInPolygon3D(\n    const Eigen::MatrixX3d&amp; polygonVertices,\n    const Eigen::RowVector3d&amp; point,\n    bool checkBoundary = true,\n    bool needClosePolygon = true\n);\n</code></pre>"},{"location":"tutorial/test_isPointInPolygon/isPointInPolygon/#parameters","title":"Parameters","text":"Parameter Type Description <code>polygonVertices</code> <code>Eigen::MatrixX2d</code> / <code>Eigen::MatrixX3d</code> Each row is a vertex. If <code>needClosePolygon</code> is <code>true</code>, the vertices may be unordered or open; the function will sort them counter-clockwise and append the first vertex to close the loop. <code>point</code> <code>Eigen::RowVector2d</code> / <code>Eigen::RowVector3d</code> Point to test. <code>checkBoundary</code> <code>bool</code> (default = <code>true</code>) <code>true</code> \u2192 points on edges/vertices count as inside; <code>false</code> \u2192 only strictly interior points count. <code>needClosePolygon</code> <code>bool</code> (default = <code>true</code>) <code>true</code> \u2192 auto-order &amp; close polygonVertices; <code>false</code> \u2192 assume vertices are already counter-clockwise and closed."},{"location":"tutorial/test_isPointInPolygon/isPointInPolygon/#return-value","title":"Return Value","text":"<ul> <li><code>true</code> if the point lies inside or on the boundary (when <code>checkBoundary=true</code>).</li> <li><code>false</code> if the point lies outside, or if the polygon is degenerate/invalid.</li> </ul>"},{"location":"tutorial/test_isPointInPolygon/isPointInPolygon/#notes","title":"Notes","text":"<ul> <li>The polygon must be simple (no self-intersections) and planar.</li> <li> <p>When <code>needClosePolygon = true</code>, the function will:</p> <ol> <li>Sort vertices counter-clockwise.</li> <li>Append the first vertex to the end to close the loop.</li> </ol> <p>Disable automatic closing (<code>needClosePolygon = false</code>) when reusing an already-processed polygon for better performance.</p> </li> </ul>"},{"location":"tutorial/test_isPointInPolygon/isPointInPolygon/#example-usage","title":"Example Usage","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n    // Unordered, unclosed 3D polygon vertices\n    Eigen::Matrix&lt;double,4,3&gt; unorderedVertices;\n    unorderedVertices &lt;&lt; 748694.4250704022, 2564734.3476669602, 49.5,\n        748674.4539194419, 2564739.5306861168, 81.5,\n        748674.4154279609, 2564734.5007915981, 49.5,\n        748694.4635618832, 2564739.3775614789, 81.5;\n\n    Eigen::RowVector3d testPoint(748674.435, 2564737.016, 65.5);    \n\n    // Test point located on one edge of the polygon\n    bool isInsideWithEdge = isPointInPolygon3D(unorderedVertices, testPoint);\n\n    // Strict: boundary does NOT count\n    bool isInsideStrict = isPointInPolygon3D(unorderedVertices, testPoint, /*checkBoundary=*/false);\n\n\n    std::cout &lt;&lt; \"Including boundary: \" &lt;&lt; insideWithEdge &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Strict interior only: \" &lt;&lt; strictInside &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre> <p>This example evaluates a point that lies on the polygon edge.</p> <p>Left: with <code>checkBoundary = true</code>, the point is considered inside (<code>true</code>).</p> <p>Right: with <code>checkBoundary = false</code>, the same point is considered outside (<code>false</code>).</p> <p></p> \u00d7"},{"location":"tutorial/test_isPointInPolyhedron/isPointInPolyhedron/","title":"isPointInPolyhedron","text":"<p>Determines whether a 3D point is located inside (or on the boundary of) a given polyhedron.</p>"},{"location":"tutorial/test_isPointInPolyhedron/isPointInPolyhedron/#function-signatures","title":"Function Signatures","text":"<pre><code>bool isPointInPolyhedron(\n    const Eigen::MatrixX3d&amp; polyhedronVertices,\n    const Eigen::RowVector3d&amp; point,\n    bool checkBoundary = true\n);\n</code></pre>"},{"location":"tutorial/test_isPointInPolyhedron/isPointInPolyhedron/#parameters","title":"Parameters","text":"Parameter Type Description <code>polyhedronVertices</code> <code>Eigen::MatrixX3d</code> A matrix of size <code>N\u00d73</code>, each row representing a polyhedron vertex. <code>point</code> <code>Eigen::RowVector3d</code> The 3D point to test for containment in the polyhedron. <code>checkBoundary</code> <code>bool</code> (default = <code>true</code>) If <code>true</code>, points lying on the polyhedron\u2019s boundary (faces or edges) are considered inside."},{"location":"tutorial/test_isPointInPolyhedron/isPointInPolyhedron/#return-value","title":"Return Value","text":"<ul> <li><code>true</code> if the point is inside the polyhedron, or on its boundary if <code>checkBoundary</code> is enabled.</li> <li><code>false</code> if the point lies strictly outside the polyhedron.</li> </ul>"},{"location":"tutorial/test_isPointInPolyhedron/isPointInPolyhedron/#example-usage","title":"Example Usage","text":"<pre><code>#include \"LiteGeometry.h\"\n\nint main() {\n    Eigen::Matrix&lt;double, 8, 3&gt; polyhedronVertices;\n    polyhedronVertices &lt;&lt; 748674.4539194419, 2564739.5306861168, 49,\n           748694.4635618832, 2564739.3775614789, 49,\n           748694.42507040221, 2564734.3476669602, 49,\n           748674.41542796092, 2564734.5007915981, 49,\n           748674.4539194419, 2564739.5306861168, 81,\n           748694.4635618832, 2564739.3775614789, 81,\n           748694.42507040221, 2564734.3476669602, 81,\n           748674.41542796092, 2564734.5007915981, 81;\n\n    Eigen::RowVector3d testPoint1(20.785733063246152, 76.974749045767595, 55.56473456);\n    Eigen::RowVector3d testPoint2(65.50742704979844, 77.06750108447973, 65.0984928161587);\n\n\n    bool insideWithBoundary1 = isPointInPolyhedron(polyhedronVertices, testPoint1);\n    bool insideStrict1   = isPointInPolyhedron(polyhedronVertices, testPoint1, false);\n\n    bool insideWithBoundary2 = isPointInPolyhedron(polyhedronVertices, testPoint2);\n    bool insideStrict2   = isPointInPolyhedron(polyhedronVertices, testPoint2, false);\n\n    std::cout &lt;&lt; \"TestPoint1 (on face/edge):\\n\"\n              &lt;&lt; \"  Including boundary: \" &lt;&lt; insideWithBoundary1 &lt;&lt; \"\\n\"\n              &lt;&lt; \"  Strict only:       \" &lt;&lt; insideStrict1   &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"TestPoint2 (interior):\\n\"\n              &lt;&lt; \"  Including boundary: \" &lt;&lt; insideWithBoundary2 &lt;&lt; \"\\n\"\n              &lt;&lt; \"  Strict only:       \" &lt;&lt; insideStrict2   &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre> <p>These examples demonstrate how the <code>checkBoundary</code> flag affects the classification of two test points:</p> <ul> <li>When <code>checkBoundary = false</code> (left image)\uff0cboth points are considered outside the polyhedron</li> <li>When <code>checkBoundary = true</code> (right image)\uff0cboth points are considered inside the polyhedron.</li> </ul> <p></p> \u00d7"},{"location":"tutorial/test_isPointOnLine/isPointOnLine/","title":"isPointOnLine (2D &amp; 3D)","text":"<p>Determine whether a query point lies on a specified line primitive in 2D or 3D space.</p> <p>Supported types include:</p> <ul> <li>2D: <code>Segment2D</code>, <code>Ray2D</code>, or <code>Line2D</code></li> <li>3D: <code>Segment3D</code>, <code>Ray3D</code>, or <code>Line3D</code></li> </ul>"},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#overview","title":"Overview","text":"<p>A query point P is considered on the primitive AB when both conditions hold:</p> Criterion Meaning Collinearity P, A, and B are collinear (within numerical tolerance). Parametric bounds P falls within the parameter range that defines the primitive: \u00a0\u00a0\u2022 Segment \u2013 between (or at) the endpoints. \u00a0\u00a0\u2022 Ray \u2013 on or beyond the origin, in the ray\u2019s direction. \u00a0\u00a0\u2022 Line \u2013 unbounded; any collinear point qualifies."},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#2d-version","title":"2D Version","text":""},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#function-signatures","title":"Function Signatures","text":"<pre><code>template&lt;typename LineT&gt;\nbool isPointOnLine2D(\n    const LineT&amp; geoAB,\n    const Eigen::RowVector2d&amp; point\n);\n</code></pre>"},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#parameters","title":"Parameters","text":"<ul> <li><code>geoAB</code> (<code>LineT</code>): 2D line primitive (<code>Segment2D</code>, <code>Ray2D</code>, <code>Line2D</code>).</li> <li><code>point</code> (<code>Eigen::RowVector2d</code>): The point to be tested.</li> </ul>"},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#return-value","title":"Return Value","text":"<ul> <li> <p><code>true</code>: <code>point</code> satisfies both Collinearity and Parametric bounds.</p> </li> <li> <p><code>false</code>: Otherwise.</p> </li> </ul>"},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#3d-version","title":"3D Version","text":""},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#function-signatures_1","title":"Function Signatures","text":"<pre><code>template&lt;typename LineT&gt;\nbool isPointOnLine3D(\n    const LineT&amp; geoAB,\n    const Eigen::RowVector3d&amp; point\n);\n</code></pre>"},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#parameters_1","title":"Parameters","text":"<ul> <li><code>geoAB</code> (<code>LineT</code>): 3D line primitive (<code>Segment3D</code>, <code>Ray3D</code>, <code>Line3D</code>).</li> <li><code>point</code> (<code>Eigen::RowVector3d</code>): The point to be tested.</li> </ul>"},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#return-value_1","title":"Return Value","text":"<p>Same as the 2D version.</p>"},{"location":"tutorial/test_isPointOnLine/isPointOnLine/#example-usage","title":"Example Usage","text":"<pre><code>#include \"LiteGeometry.h\"\nint main() {\n\n    Eigen::RowVector3d A(0, 0, 0);\n    Eigen::RowVector3d B(1, 1, 1);\n    Eigen::RowVector3d C(0.5, 0.5, 0.5);\n    Eigen::RowVector3d D(2, 2, 2);\n    Eigen::RowVector3d E(-1, -1, -1);\n    Segment3D segAB = Segment3D{ A,B };\n    Ray3D rayAB = Ray3D{ A,B };\n    Line3D lineAB = Line3D{ A,B };\n\n    std::cout &lt;&lt; \"--- On Segment AB ---\\n\";\n    std::cout &lt;&lt; \"  C on Segment AB: \" &lt;&lt; isPointOnLine3D(segAB, C) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  D on Segment AB: \" &lt;&lt; isPointOnLine3D(segAB, D) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  E on Segment AB: \" &lt;&lt; isPointOnLine3D(segAB, E) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"--- On Ray AB ---\\n\";\n    std::cout &lt;&lt; \"  C on Ray AB: \" &lt;&lt; isPointOnLine3D(rayAB, C) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  D on Ray AB: \" &lt;&lt; isPointOnLine3D(rayAB, D) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  E on Ray AB: \" &lt;&lt; isPointOnLine3D(rayAB, E) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"--- On Line AB ---\\n\";\n    std::cout &lt;&lt; \"  C on Line AB: \" &lt;&lt; isPointOnLine3D(lineAB, C) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  D on Line AB: \" &lt;&lt; isPointOnLine3D(lineAB, D) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  E on Line AB: \" &lt;&lt; isPointOnLine3D(lineAB, E) &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre> <p>The figure below visualises the test results for points C, D, and E with respect to the segment, the ray, and the infinite line defined by A and B. </p> \u00d7"},{"location":"tutorial/test_jps3D/JPSAABB/","title":"3D JPS Pathfinding (base on <code>JPSAABBEnv</code>)","text":"<p>This document describes how to perform 3D JPS using the <code>JPSAABBEnv</code> class. <code>JPSAABBEnv</code> provides high\u2011precision collision detection through CGAL\u2019s AABB tree.</p>"},{"location":"tutorial/test_jps3D/JPSAABB/#features","title":"Features","text":""},{"location":"tutorial/test_jps3D/JPSAABB/#jpsaabbpathfinder-class","title":"<code>JPSAABBPathFinder</code> Class","text":"<pre><code>/// JPSAABBPathFinder extends the JPSAABBEnv environment for 3D pathfinding \nclass JPSAABBPathFinder : public JPSAABBEnv \n{\npublic:\n    JPSAABBPathFinder(\n        const std::unordered_map&lt;size_t, SCData&gt;&amp; SCMap,\n        const std::unordered_map&lt;size_t, EFData&gt;&amp; EFMap\n    );\n    /**\n     * Executes JPS graph search between two 3D points\n     * @param startPoint  Starting position;\n     * @param endPoint    Ending position; \n     * @return A sequence of 3D integer grid coordinates representing the found path\n     */\n    std::vector&lt;Eigen::RowVector3i&gt; JPSGraphSearch(\n        const Eigen::RowVector3d&amp; startPoint, \n        const Eigen::RowVector3d&amp; endPoint \n    );\n    }\n</code></pre> <p>\u26a0\ufe0fCritical Constraint: </p> <ol> <li>Both <code>startPoint</code> and <code>endPoint</code> must lie within the navigable space defined by <code>SCMap</code>.</li> <li>Neither <code>startPoint</code> nor <code>endPoint</code> must be located inside any obstacle volume defined by <code>EFMap</code>.</li> </ol>"},{"location":"tutorial/test_jps3D/JPSAABB/#example-usage","title":"Example Usage","text":""},{"location":"tutorial/test_jps3D/JPSAABB/#1-data-preparation","title":"1. Data Preparation","text":"<p>This example uses testdata_simple.json from the repository.</p> <p>Load the navigable\u2011corridor volumes (<code>SCMap</code>) and obstacle volumes (<code>EFMap</code>) from the JSON file.  </p> <p><pre><code>// Load navigable\u2011corridor volumes (SCMap) and obstacle volumes (EFMap)\nconst auto&amp; [SCMap,EFMap] = loadVolumeMaps(\"./testData/testdata_simple.json\");\n\n// Define start/end points within bounds and outside obstacles\nEigen::RowVector3d startPoint(748876.1520, 2564890.4544, 65.5); \nEigen::RowVector3d endPoint(748678.2699, 2564651.6236, 50.0761);\n</code></pre> The following map illustrates terrain features, including obstacle zones and the navigable corridor boundaries: </p> \u00d7"},{"location":"tutorial/test_jps3D/JPSAABB/#2-environment-initialization","title":"2. Environment Initialization","text":"<p>Next, initialize the <code>JPSAABBPathFinder</code> class with the loaded spatial data.</p> <p>During construction, the class builds a CGAL\u2011based <code>DetectionObjects</code> structure (AABB tree) and stores it as a private member. This structure is later used to test whether a candidate point lies inside the corridor, on its boundary, or within an obstacle.</p> <pre><code>// Initialize pathfinder with collision detection structures\nJPSAABBPathFinder _JPSAABBPathFinder(SCMap, EFMap); // Constructs AABB trees for spatial queries\n</code></pre>"},{"location":"tutorial/test_jps3D/JPSAABB/#3-path-search-execution","title":"3. Path Search Execution","text":"<p>With the environment initialized, you can now execute JPS between the start and end points: <pre><code>// Perform JPS search\nconst auto&amp; bestPath = _JPSAABBPathFinder.JPSGraphSearch(startPoint, endPoint);\n</code></pre></p>"},{"location":"tutorial/test_jps3D/JPSAABB/#4-results","title":"4. Results","text":"<p>The resulting path is a sequence of 3D grid coordinates representing the optimal trajectory. The figure below visualizes the output:</p> \u00d7 <ul> <li>Obstacles: Represented in red.</li> <li>Navigable corridor: Shown in green.</li> <li>JPS path: Displayed as a blue polyline.</li> </ul>"},{"location":"tutorial/test_jps3D/JPSAABB/#complete-implementation","title":"Complete Implementation","text":"<pre><code>#include \"Prepare.h\"\n#include \"JPSAABBEnv.h\"\n#include &lt;chrono&gt;  \n\nint main() {\n    // Load spatial data\n    const auto&amp; [SCMap,EFMap] = loadVolumeMaps(\"./testData/testdata_simple.json\");\n\n    // Define start / end points\n    Eigen::RowVector3d startPoint(748876.1520, 2564890.4544, 65.5);\n    Eigen::RowVector3d endPoint(748678.2699, 2564651.6236, 50.0761);\n\n    // Initialise path\u2011finder (constructs AABB trees)\n    JPSAABBPathFinder _JPSAABBPathFinder(SCMap, EFMap); \n\n    // Perform JPS search and measure execution time\n    auto t0 = std::chrono::high_resolution_clock::now();\n    const auto&amp; bestPaths = _JPSAABBPathFinder.JPSGraphSearch(startPoint, endPoint);\n    auto t1 = std::chrono::high_resolution_clock::now();\n\n    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(t1 - t0);\n    std::cout &lt;&lt; \"JPSAABBPathFinder execution time: \" &lt;&lt; duration.count() &lt;&lt; \" ms\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/","title":"3D Jump Point Search Environment Models","text":"<p>In large-scale 3D maps for UAV obstacle avoidance, we have developed an efficient, reliable path-planning framework based on the 3D Jump Point Search (JPS) algorithm. This system employs advanced environment modeling and spatial decomposition techniques to enhance both preprocessing and query performance.</p> <p>This document introduces two preprocessing methods designed for JPS-based 3D path-finding in expansive environments. Each method employs a distinct spatial representation that balances collision-checking accuracy and runtime speed.</p> <p>Reference for 3D\u202fJPS: Liu, S., Watterson, M., Mohta, K., Sun, K., Bhattacharya, S., Taylor, C. J., &amp; Kumar, V. (2017). Planning dynamically feasible trajectories for quadrotors using safe flight corridors in 3D complex environments. IEEE Robotics and Automation Letters, 2(3), 1688-1695. DOI: 10.1109/LRA.2017.2663526 </p>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#core-components","title":"Core Components","text":""},{"location":"tutorial/test_jps3D/JPSCustomTypes/#gridnode-structure","title":"<code>GridNode</code> Structure","text":"<p>Represents a node in the 3D search grid: <pre><code>struct GridNode {\n    Eigen::RowVector3i position;          // Discrete 3D coordinates\n    std::vector&lt;Eigen::RowVector3i&gt; dirs; // Valid movement directions\n    double gCost = INF;                   // Cost from start to current node\n    double fCost = INF;                   // Estimated total cost (g + heuristic)\n    GridNode* parent = nullptr;           // For path back-tracking\n    priorityQueue::handle_type heapkey;   // Handle for open-list heap\n};\n</code></pre></p>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#diagonal-direction-decomposition-mapping-dirdecsmap","title":"Diagonal Direction Decomposition Mapping (<code>DirDecsMap</code>)","text":""},{"location":"tutorial/test_jps3D/JPSCustomTypes/#definition","title":"Definition","text":"<p>Maps a primary diagonal 3D direction vector to its possible decomposition directions.</p> <pre><code>using DirDecsMap = std::unordered_map&lt;\n    Eigen::RowVector3i, \n    std::vector&lt;Eigen::RowVector3i&gt;, \n    EigenRowVectoriHash\n&gt;;\n</code></pre>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#key-points","title":"Key Points","text":"<ol> <li> <p>Diagonal Decomposition      For any diagonal direction <code>(dx, dy, dz)</code> where at least two components are non-zero:</p> <ul> <li>Axis-aligned components: <code>(dx, 0, 0)</code>, <code>(0, dy, 0)</code>, <code>(0, 0, dz)</code></li> <li>Plane-diagonal components: <code>(dx, dy, 0)</code>, <code>(dx, 0, dz)</code>, <code>(0, dy, dz)</code></li> </ul> </li> <li> <p>Zero Vector Special Case    When querying <code>(0,0,0)</code>, returns all 26 possible 3D directions:    <pre><code>// Zero-vector returns all 26 possible directions\nEigen::RowVector3i(0, 0, 0) \u2192 [\n    (\u00b11, 0, 0), (0, \u00b11, 0), (0, 0, \u00b11),\n    (\u00b11, \u00b11, 0), (\u00b11, 0, \u00b11), (0, \u00b11, \u00b11),\n    (\u00b11, \u00b11, \u00b11)\n]\n</code></pre></p> </li> </ol>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#example","title":"Example","text":"<pre><code>// Get precomputed directional decomposition mappings\nDirDecsMap dirDecs = getDirDecsMap();\n\n// Get decomposition for diagonal (1,-1,1)\nauto&amp; components = dirDecs.at({1, -1, 1});\n/* Returns:\n{ {1,0,0}, {0,-1,0}, {0,0,1},  // Axis-aligned\n{1,-1,0}, {1,0,1}, {0,-1,1} }  // Plane-diagonal */\n</code></pre> <p>Use <code>DirDecsMap getDirDecsMap();</code> to generate the complete mapping.</p>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#orthogonal-directions-mapping-ortdirsmap","title":"Orthogonal Directions Mapping (<code>OrtDirsMap</code>)","text":""},{"location":"tutorial/test_jps3D/JPSCustomTypes/#definition_1","title":"Definition","text":"<p>Maps principal axis direction to its orthogonal direction set:</p> <pre><code>using OrtDirsMap = std::unordered_map&lt;\n    Eigen::RowVector3i, \n    std::vector&lt;Eigen::RowVector3i&gt;, \n    EigenRowVectoriHash\n&gt;;\n</code></pre>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#key-points_1","title":"Key Points","text":"<ol> <li> <p>Principal Axes Coverage    Contains mappings for six principal directions:    <pre><code>(\u00b11, 0, 0)  // X-axis\n(0, \u00b11, 0)  // Y-axis\n(0, 0, \u00b11)  // Z-axis\n</code></pre></p> </li> <li> <p>Orthogonal Vector Composition    For each principal direction <code>(dx, dy, dz)</code>:    <pre><code>Orthogonal vectors = [\n    (0, \u00b11, 0),   // Y-axis\n    (0, 0, \u00b11),   // Z-axis\n    (0, \u00b11, \u00b11)   // YZ-plane combinations\n]\n</code></pre></p> </li> </ol>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#example_1","title":"Example","text":"<pre><code>// Get precomputed orthogonal direction mappings\nOrtDirsMap ortDirMap = getOrtDirsMap();\n\n// Retrieve orthogonal directions for X-axis\nauto&amp; x_ortho = ortDirMap.at({1, 0, 0});\n/* Returns:\n{ {0,1,0}, {0,-1,0},      // Pure Y-axis\n  {0,0,1}, {0,0,-1},      // Pure Z-axis\n  {0,1,1}, {0,1,-1},      // YZ-plane positive\n  {0,-1,1}, {0,-1,-1} }   // YZ-plane negative */\n</code></pre> <p>Use <code>OrtDirsMap getOrtDirsMap();</code> to generate complete orthogonal mappings. </p>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#collision-detection-models","title":"Collision Detection Models","text":""},{"location":"tutorial/test_jps3D/JPSCustomTypes/#model-1-cgal-aabb-spatial-query-jpsaabbenv","title":"Model 1: CGAL-AABB Spatial Query (<code>JPSAABBEnv</code>)","text":"<p>Defines <code>DetectionObjects</code> using CGAL's AABB Tree for precise geometric queries.</p> <pre><code>typedef CGAL::Exact_predicates_inexact_constructions_kernel K;\ntypedef K::Point_3 Point_3;\ntypedef CGAL::Surface_mesh&lt;Point_3&gt; Mesh;\ntypedef CGAL::AABB_face_graph_triangle_primitive&lt;Mesh&gt; Primitive;\ntypedef CGAL::AABB_traits&lt;K, Primitive&gt; AABB_Traits;\ntypedef CGAL::AABB_tree&lt;AABB_Traits&gt; Tree;\ntypedef CGAL::Side_of_triangle_mesh&lt;Mesh, K&gt; Point_inside;\nstruct DetectionObjects {\n    Mesh scUnion;                                    // Unified navigable mesh\n    std::unique_ptr&lt;Tree&gt; scTree;                    // CGAL AABB spatial index\n    std::unique_ptr&lt;Point_inside&gt; insideSCDetecter;  // Bounded side checker\n\n    DetectionObjects(Mesh&amp;&amp; sc) : scUnion(std::move(sc)) {\n        if (!scUnion.is_empty()) {\n            scTree = std::make_unique&lt;Tree&gt;(faces(scUnion).first, faces(scUnion).second, scUnion);\n            insideSCDetecter = std::make_unique&lt;Point_inside&gt;(*scTree);\n        }\n    }\n};\n</code></pre>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#jpsaabbenv-class","title":"<code>JPSAABBEnv</code> Class","text":"<p>A high-precision, boolean-based environment model: <pre><code>class JPSAABBEnv {\npublic:\n    JPSAABBEnv(const std::unordered_map&lt;size_t, SCData&gt;&amp; SCMap,\n            const std::unordered_map&lt;size_t, EFData&gt;&amp; EFMap) {\n        initGridMap(SCMap, EFMap); // Users must implement initGridMap according to their operational environment\n    }\n\nprotected:\n    /**\u200b\n    * Checks collision status for a 3D grid position \n    * @param point Discrete grid coordinates to validate \n    * @return true if position is obstacle-free and not in boundary zones,\n    *          false otherwise \n    */\n    inline bool isMovable(const Eigen::RowVector3i&amp; point) const { \n        return (*detector-&gt;insideSCDetecter)(Point_3(point.x(), point.y(), point.z())) \n               == CGAL::ON_BOUNDED_SIDE;\n    }\n\nprivate:\n    std::unique_ptr&lt;DetectionObjects&gt; detector;\n    void initGridMap(const std::unordered_map&lt;size_t, SCData&gt;&amp; SCMap,\n                     const std::unordered_map&lt;size_t, EFData&gt;&amp; EFMap);\n};\n</code></pre></p>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#model-2-voxelized-surface-mapping-jpsvoxelenv","title":"Model 2: Voxelized Surface Mapping (<code>JPSVoxelEnv</code>)","text":"<p>Uses a <code>RowVector4iSet</code> (a customized <code>absl::flat_hash_set</code> with <code>xxHash</code>) to store rasterized voxels that enclose the surfaces of both navigable corridors and obstacles. Each voxel (<code>Eigen::RowVector4i</code>) contains:</p> <ul> <li>Grid Coordinates: First three values <code>(x, y, z)</code> as integer grid indices.</li> <li>Type Identifier: The fourth dimension distinguishes:<ul> <li>Boundary voxels of the navigable corridor (labeled 0): <ul> <li>Rasterized from the outer faces of the navigable polyhedron.</li> <li>Define the exact limits that the drone is not allowed to pass.</li> </ul> </li> <li>Obstacle Surface Voxels (labeled 1): <ul> <li>Rasterized from the faces of the obstacle polyhedra.</li> <li>Represents collision surfaces for real\u2011time avoidance.  </li> </ul> </li> </ul> </li> </ul> <p>By storing both boundary and obstacle surface voxels in a single <code>RowVector4iSet</code>, the drone can perform real-time collision checks efficiently as it moves in integer-coordinate steps within the unified grid.</p> <pre><code>static constexpr uint64_t kSeed = 0x9E3779B97F4A7C15ULL;\nstruct EigenRowVector4iHash {\n    size_t operator()(const Eigen::RowVector4i&amp; v) const {\n        return static_cast&lt;size_t&gt;(xxh::xxhash&lt;64&gt;(v.data(), sizeof(int)*3, kSeed));\n    }\n};\n\nstruct EigenRowVector4iEqual {\n    bool operator()(const Eigen::RowVector4i&amp; v1, const Eigen::RowVector4i&amp; v2) const {\n        return v1.head&lt;3&gt;() == v2.head&lt;3&gt;();\n    }\n};\n\nusing RowVector4iSet = absl::flat_hash_set&lt;\n    Eigen::RowVector4i,\n    EigenRowVector4iHash,\n    EigenRowVector4iEqual\n&gt;;\n</code></pre>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#jpsvoxelenv-class","title":"<code>JPSVoxelEnv</code> Class","text":"<p>A voxel-based discrete environment model:</p> <pre><code>class JPSVoxelEnv {\npublic:\n    JPSVoxelEnv(const std::unordered_map&lt;size_t, SCData&gt;&amp; SCMap,\n            const std::unordered_map&lt;size_t, EFData&gt;&amp; EFMap) : GridPointsSet() {\n        initGridMap(SCMap, EFMap);  // Users must implement initGridMap according to their operational environment\n    }\n\nprotected:\n    /**\u200b\n    * Checks collision status for a 3D grid position \n    * @param point Discrete grid coordinates to validate \n    * @return true if position is obstacle-free and not in boundary zones,\n    *          false otherwise \n    */\n    inline bool isMovable(const Eigen::RowVector3i&amp; point) const { \n        return GridPointsSet.find(\n            Eigen::RowVector4i(point.x(), point.y(), point.z(), 0) // 4th element not used in comparison\n        ) == GridPointsSet.end();\n    }\n\nprivate:\n    RowVector4iSet GridPointsSet;\n    void initGridMap(const std::unordered_map&lt;size_t, SCData&gt;&amp; SCSet,\n                    const std::unordered_map&lt;size_t, EFData&gt;&amp; EFSet);\n};\n</code></pre>"},{"location":"tutorial/test_jps3D/JPSCustomTypes/#performance-comparison","title":"Performance Comparison","text":"Metric <code>JPSAABBEnv</code> (CGAL-AABB) <code>JPSVoxelEnv</code> (Voxel Hashing) Query Time Complexity O(log N) O(1) Best Suited For High-precision collision checks Fast, large-scale real-time queries"},{"location":"tutorial/test_jps3D/JPSVoxel/","title":"3D JPS Pathfinding (base on <code>JPSVoxelEnv</code>)","text":"<p>This document explains how to run JPS in 3D space using the <code>JPSVoxelEnv</code> class. <code>JPSVoxelEnv</code> rasterizes corridor boundaries and obstacle surfaces into a hash-indexed voxel grid, allowing each collision check to be completed in constant time O(1).</p>"},{"location":"tutorial/test_jps3D/JPSVoxel/#features","title":"Features","text":""},{"location":"tutorial/test_jps3D/JPSVoxel/#jpsvoxelpathfinder-class","title":"<code>JPSVoxelPathFinder</code> Class","text":"<p>Implements the 3D JPS algorithm using surface rasterization optimized for UAV collision avoidance. <pre><code>// JPSPathFinder2 extends the JPSVoxelEnv environment for 3D JPS pathfinding with rasterization\nclass JPSPathFinder2 : public JPSVoxelEnv\n{\npublic:\n    JPSPathFinder2(\n        const std::unordered_map&lt;size_t, SCData&gt;&amp; SCMap,\n        const std::unordered_map&lt;size_t, EFData&gt;&amp; EFMap\n    );\n    /**\n     * Executes JPS graph search between two 3D points\n     * @param startPoint  Starting position;\n     * @param endPoint    Ending position;\n     * @return A sequence of 3D integer grid coordinates representing the found path\n     */\n    std::vector&lt;Eigen::RowVector3i&gt; JPSGraphSearch(\n        const Eigen::RowVector3d&amp; startPoint, \n        const Eigen::RowVector3d&amp; endPoint \n    );\n    }\n</code></pre></p> <p>\u26a0\ufe0fCritical Constraint: </p> <ol> <li>Both <code>startPoint</code> and <code>endPoint</code> must lie within the navigable space defined by <code>SCMap</code>.</li> <li>Neither <code>startPoint</code> nor <code>endPoint</code> must be located inside any obstacle volume defined by <code>EFMap</code>.</li> </ol>"},{"location":"tutorial/test_jps3D/JPSVoxel/#example-usage","title":"Example Usage","text":""},{"location":"tutorial/test_jps3D/JPSVoxel/#1-data-preparation","title":"1.\u202fData\u202fPreparation","text":"<p>This example uses testdata_simple.json from the repository.</p> <p>Load the navigable\u2011corridor volumes (<code>SCMap</code>) and obstacle volumes (<code>EFMap</code>) from the JSON file.  </p> <pre><code>// Load navigable\u2011corridor volumes (SCMap) and obstacle volumes (EFMap)\nconst auto&amp; [SCMap,EFMap] = loadVolumeMaps(\"./testData/testdata_simple.json\");\n\n// Define start/end points within bounds and outside obstacles\nEigen::RowVector3d startPoint(748876.1520, 2564890.4544, 65.5); \nEigen::RowVector3d endPoint(748678.2699, 2564651.6236, 50.0761);\n</code></pre> <p></p> \u00d7"},{"location":"tutorial/test_jps3D/JPSVoxel/#2-environment-initialization","title":"2.\u202fEnvironment\u202fInitialization","text":"<p>The constructor voxelizes all obstacle faces and corridor boundaries, storing them in an efficient hash set called <code>GridPointsSet</code> (a private member of <code>JPSVoxelPathFinder</code>). This enables constant\u2011time O(1) collision checks during pathfinding.</p> <pre><code>// Build the rasterised environment (voxel hash) inside the path\u2011finder\nJPSVoxelPathFinder _JPSVoxelPathFinder(SCMap, EFMap);\n</code></pre> <p>The rasterization result is visualized below:</p> \u00d7"},{"location":"tutorial/test_jps3D/JPSVoxel/#3-path-search-execution","title":"3.\u202fPath\u202fSearch\u202fExecution","text":"<p>With the voxel grid ready, execute the JPS algorithm to find a path between the two points. <pre><code>const auto&amp; bestPath = _JPSVoxelPathFinder.JPSGraphSearch(startPoint, endPoint);\n</code></pre></p>"},{"location":"tutorial/test_jps3D/JPSVoxel/#4-results","title":"4.\u202fResults","text":"<p>After the search completes, the algorithm returns a sequence of 3D grid coordinates representing the optimal path within the corridor.</p> <p>The figure below shows the result:</p> \u00d7 <ul> <li>Obstacle\u2011surface voxels: Represented in red.</li> <li>Boundary voxels of the navigable corridor: Shown in green.</li> <li>JPS path:\u2002Displayed as a blue polyline</li> </ul>"},{"location":"tutorial/test_jps3D/JPSVoxel/#complete-implementation","title":"Complete Implementation","text":"<pre><code>#include \"Prepare.h\"\n#include \"JPSVoxelEnv.h\"\n#include &lt;chrono&gt;  \n\nint main() {\n    // Load spatial data\n    const auto&amp; [SCMap,EFMap] = loadVolumeMaps(\"./testData/testdata_simple.json\");\n\n    // Define start / end points\n    Eigen::RowVector3d startPoint(748876.1520, 2564890.4544, 65.5);\n    Eigen::RowVector3d endPoint(748678.2699, 2564651.6236, 50.0761);\n\n    // Initialise path\u2011finder (builds voxel hash)\n    JPSVoxelPathFinder _JPSVoxelPathFinder(SCMap, EFMap);\n\n    // Perform JPS search and measure execution time\n    auto t0 = std::chrono::high_resolution_clock::now();\n    const auto&amp; bestPaths = _JPSVoxelPathFinder.JPSGraphSearch(startPoint, endPoint);\n    auto t1 = std::chrono::high_resolution_clock::now();\n\n    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(t1 - t0);\n    std::cout &lt;&lt; \"JPSVoxelPathFinder execution time: \" &lt;&lt; duration.count() &lt;&lt; \" ms\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"}]}